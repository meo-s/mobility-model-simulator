// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/mobmodel-simulator.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fmobmodel_2dsimulator_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fmobmodel_2dsimulator_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fmobmodel_2dsimulator_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fmobmodel_2dsimulator_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fmobmodel_2dsimulator_2eproto;
namespace pb {
class CameraConfig;
struct CameraConfigDefaultTypeInternal;
extern CameraConfigDefaultTypeInternal _CameraConfig_default_instance_;
class CoverageMapConfig;
struct CoverageMapConfigDefaultTypeInternal;
extern CoverageMapConfigDefaultTypeInternal _CoverageMapConfig_default_instance_;
class MobilityModelSimulatorApproxMap;
struct MobilityModelSimulatorApproxMapDefaultTypeInternal;
extern MobilityModelSimulatorApproxMapDefaultTypeInternal _MobilityModelSimulatorApproxMap_default_instance_;
class MobilityModelSimulatorConfig;
struct MobilityModelSimulatorConfigDefaultTypeInternal;
extern MobilityModelSimulatorConfigDefaultTypeInternal _MobilityModelSimulatorConfig_default_instance_;
class MobilityModelSimulatorFrameInfo;
struct MobilityModelSimulatorFrameInfoDefaultTypeInternal;
extern MobilityModelSimulatorFrameInfoDefaultTypeInternal _MobilityModelSimulatorFrameInfo_default_instance_;
class UAV;
struct UAVDefaultTypeInternal;
extern UAVDefaultTypeInternal _UAV_default_instance_;
class UAVConfig;
struct UAVConfigDefaultTypeInternal;
extern UAVConfigDefaultTypeInternal _UAVConfig_default_instance_;
class Vec2f;
struct Vec2fDefaultTypeInternal;
extern Vec2fDefaultTypeInternal _Vec2f_default_instance_;
class Vec3f;
struct Vec3fDefaultTypeInternal;
extern Vec3fDefaultTypeInternal _Vec3f_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::CameraConfig* Arena::CreateMaybeMessage<::pb::CameraConfig>(Arena*);
template<> ::pb::CoverageMapConfig* Arena::CreateMaybeMessage<::pb::CoverageMapConfig>(Arena*);
template<> ::pb::MobilityModelSimulatorApproxMap* Arena::CreateMaybeMessage<::pb::MobilityModelSimulatorApproxMap>(Arena*);
template<> ::pb::MobilityModelSimulatorConfig* Arena::CreateMaybeMessage<::pb::MobilityModelSimulatorConfig>(Arena*);
template<> ::pb::MobilityModelSimulatorFrameInfo* Arena::CreateMaybeMessage<::pb::MobilityModelSimulatorFrameInfo>(Arena*);
template<> ::pb::UAV* Arena::CreateMaybeMessage<::pb::UAV>(Arena*);
template<> ::pb::UAVConfig* Arena::CreateMaybeMessage<::pb::UAVConfig>(Arena*);
template<> ::pb::Vec2f* Arena::CreateMaybeMessage<::pb::Vec2f>(Arena*);
template<> ::pb::Vec3f* Arena::CreateMaybeMessage<::pb::Vec3f>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

enum UAVType : int {
  UNKNOWN_UAV_TYPE = 0,
  ROTARY_WING = 1,
  FIXED_WING = 2,
  UAVType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UAVType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UAVType_IsValid(int value);
constexpr UAVType UAVType_MIN = UNKNOWN_UAV_TYPE;
constexpr UAVType UAVType_MAX = FIXED_WING;
constexpr int UAVType_ARRAYSIZE = UAVType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UAVType_descriptor();
template<typename T>
inline const std::string& UAVType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UAVType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UAVType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UAVType_descriptor(), enum_t_value);
}
inline bool UAVType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UAVType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UAVType>(
    UAVType_descriptor(), name, value);
}
enum MobilityModel : int {
  UNKNOWN_MOBILITY_MODEL = 0,
  RANDOM_WAYPOINT = 1,
  MobilityModel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MobilityModel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MobilityModel_IsValid(int value);
constexpr MobilityModel MobilityModel_MIN = UNKNOWN_MOBILITY_MODEL;
constexpr MobilityModel MobilityModel_MAX = RANDOM_WAYPOINT;
constexpr int MobilityModel_ARRAYSIZE = MobilityModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MobilityModel_descriptor();
template<typename T>
inline const std::string& MobilityModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MobilityModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MobilityModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MobilityModel_descriptor(), enum_t_value);
}
inline bool MobilityModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MobilityModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MobilityModel>(
    MobilityModel_descriptor(), name, value);
}
enum MobilityModelSimulatorState : int {
  IDLE = 0,
  RUNNING = 1,
  MobilityModelSimulatorState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MobilityModelSimulatorState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MobilityModelSimulatorState_IsValid(int value);
constexpr MobilityModelSimulatorState MobilityModelSimulatorState_MIN = IDLE;
constexpr MobilityModelSimulatorState MobilityModelSimulatorState_MAX = RUNNING;
constexpr int MobilityModelSimulatorState_ARRAYSIZE = MobilityModelSimulatorState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MobilityModelSimulatorState_descriptor();
template<typename T>
inline const std::string& MobilityModelSimulatorState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MobilityModelSimulatorState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MobilityModelSimulatorState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MobilityModelSimulatorState_descriptor(), enum_t_value);
}
inline bool MobilityModelSimulatorState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MobilityModelSimulatorState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MobilityModelSimulatorState>(
    MobilityModelSimulatorState_descriptor(), name, value);
}
// ===================================================================

class Vec2f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Vec2f) */ {
 public:
  inline Vec2f() : Vec2f(nullptr) {}
  ~Vec2f() override;
  explicit constexpr Vec2f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec2f(const Vec2f& from);
  Vec2f(Vec2f&& from) noexcept
    : Vec2f() {
    *this = ::std::move(from);
  }

  inline Vec2f& operator=(const Vec2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2f& operator=(Vec2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec2f* internal_default_instance() {
    return reinterpret_cast<const Vec2f*>(
               &_Vec2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec2f& a, Vec2f& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec2f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec2f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec2f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec2f& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Vec2f";
  }
  protected:
  explicit Vec2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Vec2f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// -------------------------------------------------------------------

class Vec3f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Vec3f) */ {
 public:
  inline Vec3f() : Vec3f(nullptr) {}
  ~Vec3f() override;
  explicit constexpr Vec3f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vec3f(const Vec3f& from);
  Vec3f(Vec3f&& from) noexcept
    : Vec3f() {
    *this = ::std::move(from);
  }

  inline Vec3f& operator=(const Vec3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3f& operator=(Vec3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3f* internal_default_instance() {
    return reinterpret_cast<const Vec3f*>(
               &_Vec3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec3f& a, Vec3f& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vec3f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vec3f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vec3f& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Vec3f";
  }
  protected:
  explicit Vec3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Vec3f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// -------------------------------------------------------------------

class UAV final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.UAV) */ {
 public:
  inline UAV() : UAV(nullptr) {}
  ~UAV() override;
  explicit constexpr UAV(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UAV(const UAV& from);
  UAV(UAV&& from) noexcept
    : UAV() {
    *this = ::std::move(from);
  }

  inline UAV& operator=(const UAV& from) {
    CopyFrom(from);
    return *this;
  }
  inline UAV& operator=(UAV&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UAV& default_instance() {
    return *internal_default_instance();
  }
  static inline const UAV* internal_default_instance() {
    return reinterpret_cast<const UAV*>(
               &_UAV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UAV& a, UAV& b) {
    a.Swap(&b);
  }
  inline void Swap(UAV* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UAV* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UAV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UAV>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UAV& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UAV& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UAV* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.UAV";
  }
  protected:
  explicit UAV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kDestinationFieldNumber = 3,
    kIndexFieldNumber = 1,
  };
  // .pb.Vec3f position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::pb::Vec3f& position() const;
  PROTOBUF_NODISCARD ::pb::Vec3f* release_position();
  ::pb::Vec3f* mutable_position();
  void set_allocated_position(::pb::Vec3f* position);
  private:
  const ::pb::Vec3f& _internal_position() const;
  ::pb::Vec3f* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::pb::Vec3f* position);
  ::pb::Vec3f* unsafe_arena_release_position();

  // .pb.Vec2f destination = 3;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::pb::Vec2f& destination() const;
  PROTOBUF_NODISCARD ::pb::Vec2f* release_destination();
  ::pb::Vec2f* mutable_destination();
  void set_allocated_destination(::pb::Vec2f* destination);
  private:
  const ::pb::Vec2f& _internal_destination() const;
  ::pb::Vec2f* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::pb::Vec2f* destination);
  ::pb::Vec2f* unsafe_arena_release_destination();

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.UAV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pb::Vec3f* position_;
  ::pb::Vec2f* destination_;
  uint32_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// -------------------------------------------------------------------

class CoverageMapConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.CoverageMapConfig) */ {
 public:
  inline CoverageMapConfig() : CoverageMapConfig(nullptr) {}
  ~CoverageMapConfig() override;
  explicit constexpr CoverageMapConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoverageMapConfig(const CoverageMapConfig& from);
  CoverageMapConfig(CoverageMapConfig&& from) noexcept
    : CoverageMapConfig() {
    *this = ::std::move(from);
  }

  inline CoverageMapConfig& operator=(const CoverageMapConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoverageMapConfig& operator=(CoverageMapConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoverageMapConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoverageMapConfig* internal_default_instance() {
    return reinterpret_cast<const CoverageMapConfig*>(
               &_CoverageMapConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CoverageMapConfig& a, CoverageMapConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CoverageMapConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoverageMapConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoverageMapConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoverageMapConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoverageMapConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoverageMapConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoverageMapConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.CoverageMapConfig";
  }
  protected:
  explicit CoverageMapConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapHeightFieldNumber = 1,
    kMapWidthFieldNumber = 2,
    kCellSizeFieldNumber = 3,
  };
  // double map_height = 1;
  void clear_map_height();
  double map_height() const;
  void set_map_height(double value);
  private:
  double _internal_map_height() const;
  void _internal_set_map_height(double value);
  public:

  // double map_width = 2;
  void clear_map_width();
  double map_width() const;
  void set_map_width(double value);
  private:
  double _internal_map_width() const;
  void _internal_set_map_width(double value);
  public:

  // double cell_size = 3;
  void clear_cell_size();
  double cell_size() const;
  void set_cell_size(double value);
  private:
  double _internal_cell_size() const;
  void _internal_set_cell_size(double value);
  public:

  // @@protoc_insertion_point(class_scope:pb.CoverageMapConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double map_height_;
  double map_width_;
  double cell_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// -------------------------------------------------------------------

class CameraConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.CameraConfig) */ {
 public:
  inline CameraConfig() : CameraConfig(nullptr) {}
  ~CameraConfig() override;
  explicit constexpr CameraConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraConfig(const CameraConfig& from);
  CameraConfig(CameraConfig&& from) noexcept
    : CameraConfig() {
    *this = ::std::move(from);
  }

  inline CameraConfig& operator=(const CameraConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraConfig& operator=(CameraConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraConfig* internal_default_instance() {
    return reinterpret_cast<const CameraConfig*>(
               &_CameraConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CameraConfig& a, CameraConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CameraConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CameraConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.CameraConfig";
  }
  protected:
  explicit CameraConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHfovFieldNumber = 1,
    kVfovFieldNumber = 2,
  };
  // double hfov = 1;
  void clear_hfov();
  double hfov() const;
  void set_hfov(double value);
  private:
  double _internal_hfov() const;
  void _internal_set_hfov(double value);
  public:

  // double vfov = 2;
  void clear_vfov();
  double vfov() const;
  void set_vfov(double value);
  private:
  double _internal_vfov() const;
  void _internal_set_vfov(double value);
  public:

  // @@protoc_insertion_point(class_scope:pb.CameraConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double hfov_;
  double vfov_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// -------------------------------------------------------------------

class UAVConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.UAVConfig) */ {
 public:
  inline UAVConfig() : UAVConfig(nullptr) {}
  ~UAVConfig() override;
  explicit constexpr UAVConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UAVConfig(const UAVConfig& from);
  UAVConfig(UAVConfig&& from) noexcept
    : UAVConfig() {
    *this = ::std::move(from);
  }

  inline UAVConfig& operator=(const UAVConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline UAVConfig& operator=(UAVConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UAVConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const UAVConfig* internal_default_instance() {
    return reinterpret_cast<const UAVConfig*>(
               &_UAVConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UAVConfig& a, UAVConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(UAVConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UAVConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UAVConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UAVConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UAVConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UAVConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UAVConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.UAVConfig";
  }
  protected:
  explicit UAVConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraCfgFieldNumber = 1,
    kMassFieldNumber = 2,
    kMaxThrustFieldNumber = 3,
    kMaxSpeedFieldNumber = 4,
    kAltitudeFieldNumber = 5,
    kBankAngleFieldNumber = 6,
    kUavTypeFieldNumber = 7,
  };
  // .pb.CameraConfig camera_cfg = 1;
  bool has_camera_cfg() const;
  private:
  bool _internal_has_camera_cfg() const;
  public:
  void clear_camera_cfg();
  const ::pb::CameraConfig& camera_cfg() const;
  PROTOBUF_NODISCARD ::pb::CameraConfig* release_camera_cfg();
  ::pb::CameraConfig* mutable_camera_cfg();
  void set_allocated_camera_cfg(::pb::CameraConfig* camera_cfg);
  private:
  const ::pb::CameraConfig& _internal_camera_cfg() const;
  ::pb::CameraConfig* _internal_mutable_camera_cfg();
  public:
  void unsafe_arena_set_allocated_camera_cfg(
      ::pb::CameraConfig* camera_cfg);
  ::pb::CameraConfig* unsafe_arena_release_camera_cfg();

  // float mass = 2;
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // float max_thrust = 3;
  void clear_max_thrust();
  float max_thrust() const;
  void set_max_thrust(float value);
  private:
  float _internal_max_thrust() const;
  void _internal_set_max_thrust(float value);
  public:

  // float max_speed = 4;
  void clear_max_speed();
  float max_speed() const;
  void set_max_speed(float value);
  private:
  float _internal_max_speed() const;
  void _internal_set_max_speed(float value);
  public:

  // float altitude = 5;
  void clear_altitude();
  float altitude() const;
  void set_altitude(float value);
  private:
  float _internal_altitude() const;
  void _internal_set_altitude(float value);
  public:

  // float bank_angle = 6;
  void clear_bank_angle();
  float bank_angle() const;
  void set_bank_angle(float value);
  private:
  float _internal_bank_angle() const;
  void _internal_set_bank_angle(float value);
  public:

  // .pb.UAVType uav_type = 7;
  void clear_uav_type();
  ::pb::UAVType uav_type() const;
  void set_uav_type(::pb::UAVType value);
  private:
  ::pb::UAVType _internal_uav_type() const;
  void _internal_set_uav_type(::pb::UAVType value);
  public:

  // @@protoc_insertion_point(class_scope:pb.UAVConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pb::CameraConfig* camera_cfg_;
  float mass_;
  float max_thrust_;
  float max_speed_;
  float altitude_;
  float bank_angle_;
  int uav_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// -------------------------------------------------------------------

class MobilityModelSimulatorConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.MobilityModelSimulatorConfig) */ {
 public:
  inline MobilityModelSimulatorConfig() : MobilityModelSimulatorConfig(nullptr) {}
  ~MobilityModelSimulatorConfig() override;
  explicit constexpr MobilityModelSimulatorConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MobilityModelSimulatorConfig(const MobilityModelSimulatorConfig& from);
  MobilityModelSimulatorConfig(MobilityModelSimulatorConfig&& from) noexcept
    : MobilityModelSimulatorConfig() {
    *this = ::std::move(from);
  }

  inline MobilityModelSimulatorConfig& operator=(const MobilityModelSimulatorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MobilityModelSimulatorConfig& operator=(MobilityModelSimulatorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MobilityModelSimulatorConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MobilityModelSimulatorConfig* internal_default_instance() {
    return reinterpret_cast<const MobilityModelSimulatorConfig*>(
               &_MobilityModelSimulatorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MobilityModelSimulatorConfig& a, MobilityModelSimulatorConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MobilityModelSimulatorConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MobilityModelSimulatorConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MobilityModelSimulatorConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MobilityModelSimulatorConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MobilityModelSimulatorConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MobilityModelSimulatorConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MobilityModelSimulatorConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.MobilityModelSimulatorConfig";
  }
  protected:
  explicit MobilityModelSimulatorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoverageMapCfgFieldNumber = 2,
    kUavCfgFieldNumber = 3,
    kMobmodelFieldNumber = 1,
    kNUavsFieldNumber = 4,
  };
  // .pb.CoverageMapConfig coverage_map_cfg = 2;
  bool has_coverage_map_cfg() const;
  private:
  bool _internal_has_coverage_map_cfg() const;
  public:
  void clear_coverage_map_cfg();
  const ::pb::CoverageMapConfig& coverage_map_cfg() const;
  PROTOBUF_NODISCARD ::pb::CoverageMapConfig* release_coverage_map_cfg();
  ::pb::CoverageMapConfig* mutable_coverage_map_cfg();
  void set_allocated_coverage_map_cfg(::pb::CoverageMapConfig* coverage_map_cfg);
  private:
  const ::pb::CoverageMapConfig& _internal_coverage_map_cfg() const;
  ::pb::CoverageMapConfig* _internal_mutable_coverage_map_cfg();
  public:
  void unsafe_arena_set_allocated_coverage_map_cfg(
      ::pb::CoverageMapConfig* coverage_map_cfg);
  ::pb::CoverageMapConfig* unsafe_arena_release_coverage_map_cfg();

  // .pb.UAVConfig uav_cfg = 3;
  bool has_uav_cfg() const;
  private:
  bool _internal_has_uav_cfg() const;
  public:
  void clear_uav_cfg();
  const ::pb::UAVConfig& uav_cfg() const;
  PROTOBUF_NODISCARD ::pb::UAVConfig* release_uav_cfg();
  ::pb::UAVConfig* mutable_uav_cfg();
  void set_allocated_uav_cfg(::pb::UAVConfig* uav_cfg);
  private:
  const ::pb::UAVConfig& _internal_uav_cfg() const;
  ::pb::UAVConfig* _internal_mutable_uav_cfg();
  public:
  void unsafe_arena_set_allocated_uav_cfg(
      ::pb::UAVConfig* uav_cfg);
  ::pb::UAVConfig* unsafe_arena_release_uav_cfg();

  // .pb.MobilityModel mobmodel = 1;
  void clear_mobmodel();
  ::pb::MobilityModel mobmodel() const;
  void set_mobmodel(::pb::MobilityModel value);
  private:
  ::pb::MobilityModel _internal_mobmodel() const;
  void _internal_set_mobmodel(::pb::MobilityModel value);
  public:

  // uint32 n_uavs = 4;
  void clear_n_uavs();
  uint32_t n_uavs() const;
  void set_n_uavs(uint32_t value);
  private:
  uint32_t _internal_n_uavs() const;
  void _internal_set_n_uavs(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.MobilityModelSimulatorConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pb::CoverageMapConfig* coverage_map_cfg_;
  ::pb::UAVConfig* uav_cfg_;
  int mobmodel_;
  uint32_t n_uavs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// -------------------------------------------------------------------

class MobilityModelSimulatorFrameInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.MobilityModelSimulatorFrameInfo) */ {
 public:
  inline MobilityModelSimulatorFrameInfo() : MobilityModelSimulatorFrameInfo(nullptr) {}
  ~MobilityModelSimulatorFrameInfo() override;
  explicit constexpr MobilityModelSimulatorFrameInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MobilityModelSimulatorFrameInfo(const MobilityModelSimulatorFrameInfo& from);
  MobilityModelSimulatorFrameInfo(MobilityModelSimulatorFrameInfo&& from) noexcept
    : MobilityModelSimulatorFrameInfo() {
    *this = ::std::move(from);
  }

  inline MobilityModelSimulatorFrameInfo& operator=(const MobilityModelSimulatorFrameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MobilityModelSimulatorFrameInfo& operator=(MobilityModelSimulatorFrameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MobilityModelSimulatorFrameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MobilityModelSimulatorFrameInfo* internal_default_instance() {
    return reinterpret_cast<const MobilityModelSimulatorFrameInfo*>(
               &_MobilityModelSimulatorFrameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MobilityModelSimulatorFrameInfo& a, MobilityModelSimulatorFrameInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MobilityModelSimulatorFrameInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MobilityModelSimulatorFrameInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MobilityModelSimulatorFrameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MobilityModelSimulatorFrameInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MobilityModelSimulatorFrameInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MobilityModelSimulatorFrameInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MobilityModelSimulatorFrameInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.MobilityModelSimulatorFrameInfo";
  }
  protected:
  explicit MobilityModelSimulatorFrameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUavsFieldNumber = 4,
    kStateFieldNumber = 1,
    kSimulationTimeFieldNumber = 2,
    kCoverageRatioFieldNumber = 3,
  };
  // repeated .pb.UAV uavs = 4;
  int uavs_size() const;
  private:
  int _internal_uavs_size() const;
  public:
  void clear_uavs();
  ::pb::UAV* mutable_uavs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::UAV >*
      mutable_uavs();
  private:
  const ::pb::UAV& _internal_uavs(int index) const;
  ::pb::UAV* _internal_add_uavs();
  public:
  const ::pb::UAV& uavs(int index) const;
  ::pb::UAV* add_uavs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::UAV >&
      uavs() const;

  // .pb.MobilityModelSimulatorState state = 1;
  void clear_state();
  ::pb::MobilityModelSimulatorState state() const;
  void set_state(::pb::MobilityModelSimulatorState value);
  private:
  ::pb::MobilityModelSimulatorState _internal_state() const;
  void _internal_set_state(::pb::MobilityModelSimulatorState value);
  public:

  // float simulation_time = 2;
  void clear_simulation_time();
  float simulation_time() const;
  void set_simulation_time(float value);
  private:
  float _internal_simulation_time() const;
  void _internal_set_simulation_time(float value);
  public:

  // float coverage_ratio = 3;
  void clear_coverage_ratio();
  float coverage_ratio() const;
  void set_coverage_ratio(float value);
  private:
  float _internal_coverage_ratio() const;
  void _internal_set_coverage_ratio(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.MobilityModelSimulatorFrameInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::UAV > uavs_;
  int state_;
  float simulation_time_;
  float coverage_ratio_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// -------------------------------------------------------------------

class MobilityModelSimulatorApproxMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.MobilityModelSimulatorApproxMap) */ {
 public:
  inline MobilityModelSimulatorApproxMap() : MobilityModelSimulatorApproxMap(nullptr) {}
  ~MobilityModelSimulatorApproxMap() override;
  explicit constexpr MobilityModelSimulatorApproxMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MobilityModelSimulatorApproxMap(const MobilityModelSimulatorApproxMap& from);
  MobilityModelSimulatorApproxMap(MobilityModelSimulatorApproxMap&& from) noexcept
    : MobilityModelSimulatorApproxMap() {
    *this = ::std::move(from);
  }

  inline MobilityModelSimulatorApproxMap& operator=(const MobilityModelSimulatorApproxMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline MobilityModelSimulatorApproxMap& operator=(MobilityModelSimulatorApproxMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MobilityModelSimulatorApproxMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const MobilityModelSimulatorApproxMap* internal_default_instance() {
    return reinterpret_cast<const MobilityModelSimulatorApproxMap*>(
               &_MobilityModelSimulatorApproxMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MobilityModelSimulatorApproxMap& a, MobilityModelSimulatorApproxMap& b) {
    a.Swap(&b);
  }
  inline void Swap(MobilityModelSimulatorApproxMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MobilityModelSimulatorApproxMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MobilityModelSimulatorApproxMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MobilityModelSimulatorApproxMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MobilityModelSimulatorApproxMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MobilityModelSimulatorApproxMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MobilityModelSimulatorApproxMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.MobilityModelSimulatorApproxMap";
  }
  protected:
  explicit MobilityModelSimulatorApproxMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZonesFieldNumber = 3,
    kRowsFieldNumber = 1,
    kColsFieldNumber = 2,
  };
  // repeated uint32 zones = 3;
  int zones_size() const;
  private:
  int _internal_zones_size() const;
  public:
  void clear_zones();
  private:
  uint32_t _internal_zones(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_zones() const;
  void _internal_add_zones(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_zones();
  public:
  uint32_t zones(int index) const;
  void set_zones(int index, uint32_t value);
  void add_zones(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      zones() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_zones();

  // uint32 rows = 1;
  void clear_rows();
  uint32_t rows() const;
  void set_rows(uint32_t value);
  private:
  uint32_t _internal_rows() const;
  void _internal_set_rows(uint32_t value);
  public:

  // uint32 cols = 2;
  void clear_cols();
  uint32_t cols() const;
  void set_cols(uint32_t value);
  private:
  uint32_t _internal_cols() const;
  void _internal_set_cols(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.MobilityModelSimulatorApproxMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > zones_;
  mutable std::atomic<int> _zones_cached_byte_size_;
  uint32_t rows_;
  uint32_t cols_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmobmodel_2dsimulator_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec2f

// float x = 1;
inline void Vec2f::clear_x() {
  x_ = 0;
}
inline float Vec2f::_internal_x() const {
  return x_;
}
inline float Vec2f::x() const {
  // @@protoc_insertion_point(field_get:pb.Vec2f.x)
  return _internal_x();
}
inline void Vec2f::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec2f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:pb.Vec2f.x)
}

// float y = 2;
inline void Vec2f::clear_y() {
  y_ = 0;
}
inline float Vec2f::_internal_y() const {
  return y_;
}
inline float Vec2f::y() const {
  // @@protoc_insertion_point(field_get:pb.Vec2f.y)
  return _internal_y();
}
inline void Vec2f::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec2f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:pb.Vec2f.y)
}

// -------------------------------------------------------------------

// Vec3f

// float x = 1;
inline void Vec3f::clear_x() {
  x_ = 0;
}
inline float Vec3f::_internal_x() const {
  return x_;
}
inline float Vec3f::x() const {
  // @@protoc_insertion_point(field_get:pb.Vec3f.x)
  return _internal_x();
}
inline void Vec3f::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec3f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:pb.Vec3f.x)
}

// float y = 2;
inline void Vec3f::clear_y() {
  y_ = 0;
}
inline float Vec3f::_internal_y() const {
  return y_;
}
inline float Vec3f::y() const {
  // @@protoc_insertion_point(field_get:pb.Vec3f.y)
  return _internal_y();
}
inline void Vec3f::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec3f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:pb.Vec3f.y)
}

// float z = 3;
inline void Vec3f::clear_z() {
  z_ = 0;
}
inline float Vec3f::_internal_z() const {
  return z_;
}
inline float Vec3f::z() const {
  // @@protoc_insertion_point(field_get:pb.Vec3f.z)
  return _internal_z();
}
inline void Vec3f::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vec3f::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:pb.Vec3f.z)
}

// -------------------------------------------------------------------

// UAV

// uint32 index = 1;
inline void UAV::clear_index() {
  index_ = 0u;
}
inline uint32_t UAV::_internal_index() const {
  return index_;
}
inline uint32_t UAV::index() const {
  // @@protoc_insertion_point(field_get:pb.UAV.index)
  return _internal_index();
}
inline void UAV::_internal_set_index(uint32_t value) {
  
  index_ = value;
}
inline void UAV::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:pb.UAV.index)
}

// .pb.Vec3f position = 2;
inline bool UAV::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool UAV::has_position() const {
  return _internal_has_position();
}
inline void UAV::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::pb::Vec3f& UAV::_internal_position() const {
  const ::pb::Vec3f* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Vec3f&>(
      ::pb::_Vec3f_default_instance_);
}
inline const ::pb::Vec3f& UAV::position() const {
  // @@protoc_insertion_point(field_get:pb.UAV.position)
  return _internal_position();
}
inline void UAV::unsafe_arena_set_allocated_position(
    ::pb::Vec3f* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.UAV.position)
}
inline ::pb::Vec3f* UAV::release_position() {
  
  ::pb::Vec3f* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::Vec3f* UAV::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:pb.UAV.position)
  
  ::pb::Vec3f* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::pb::Vec3f* UAV::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Vec3f>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::pb::Vec3f* UAV::mutable_position() {
  ::pb::Vec3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:pb.UAV.position)
  return _msg;
}
inline void UAV::set_allocated_position(::pb::Vec3f* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::Vec3f>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:pb.UAV.position)
}

// .pb.Vec2f destination = 3;
inline bool UAV::_internal_has_destination() const {
  return this != internal_default_instance() && destination_ != nullptr;
}
inline bool UAV::has_destination() const {
  return _internal_has_destination();
}
inline void UAV::clear_destination() {
  if (GetArenaForAllocation() == nullptr && destination_ != nullptr) {
    delete destination_;
  }
  destination_ = nullptr;
}
inline const ::pb::Vec2f& UAV::_internal_destination() const {
  const ::pb::Vec2f* p = destination_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Vec2f&>(
      ::pb::_Vec2f_default_instance_);
}
inline const ::pb::Vec2f& UAV::destination() const {
  // @@protoc_insertion_point(field_get:pb.UAV.destination)
  return _internal_destination();
}
inline void UAV::unsafe_arena_set_allocated_destination(
    ::pb::Vec2f* destination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(destination_);
  }
  destination_ = destination;
  if (destination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.UAV.destination)
}
inline ::pb::Vec2f* UAV::release_destination() {
  
  ::pb::Vec2f* temp = destination_;
  destination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::Vec2f* UAV::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_release:pb.UAV.destination)
  
  ::pb::Vec2f* temp = destination_;
  destination_ = nullptr;
  return temp;
}
inline ::pb::Vec2f* UAV::_internal_mutable_destination() {
  
  if (destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Vec2f>(GetArenaForAllocation());
    destination_ = p;
  }
  return destination_;
}
inline ::pb::Vec2f* UAV::mutable_destination() {
  ::pb::Vec2f* _msg = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:pb.UAV.destination)
  return _msg;
}
inline void UAV::set_allocated_destination(::pb::Vec2f* destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete destination_;
  }
  if (destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::Vec2f>::GetOwningArena(destination);
    if (message_arena != submessage_arena) {
      destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    
  } else {
    
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:pb.UAV.destination)
}

// -------------------------------------------------------------------

// CoverageMapConfig

// double map_height = 1;
inline void CoverageMapConfig::clear_map_height() {
  map_height_ = 0;
}
inline double CoverageMapConfig::_internal_map_height() const {
  return map_height_;
}
inline double CoverageMapConfig::map_height() const {
  // @@protoc_insertion_point(field_get:pb.CoverageMapConfig.map_height)
  return _internal_map_height();
}
inline void CoverageMapConfig::_internal_set_map_height(double value) {
  
  map_height_ = value;
}
inline void CoverageMapConfig::set_map_height(double value) {
  _internal_set_map_height(value);
  // @@protoc_insertion_point(field_set:pb.CoverageMapConfig.map_height)
}

// double map_width = 2;
inline void CoverageMapConfig::clear_map_width() {
  map_width_ = 0;
}
inline double CoverageMapConfig::_internal_map_width() const {
  return map_width_;
}
inline double CoverageMapConfig::map_width() const {
  // @@protoc_insertion_point(field_get:pb.CoverageMapConfig.map_width)
  return _internal_map_width();
}
inline void CoverageMapConfig::_internal_set_map_width(double value) {
  
  map_width_ = value;
}
inline void CoverageMapConfig::set_map_width(double value) {
  _internal_set_map_width(value);
  // @@protoc_insertion_point(field_set:pb.CoverageMapConfig.map_width)
}

// double cell_size = 3;
inline void CoverageMapConfig::clear_cell_size() {
  cell_size_ = 0;
}
inline double CoverageMapConfig::_internal_cell_size() const {
  return cell_size_;
}
inline double CoverageMapConfig::cell_size() const {
  // @@protoc_insertion_point(field_get:pb.CoverageMapConfig.cell_size)
  return _internal_cell_size();
}
inline void CoverageMapConfig::_internal_set_cell_size(double value) {
  
  cell_size_ = value;
}
inline void CoverageMapConfig::set_cell_size(double value) {
  _internal_set_cell_size(value);
  // @@protoc_insertion_point(field_set:pb.CoverageMapConfig.cell_size)
}

// -------------------------------------------------------------------

// CameraConfig

// double hfov = 1;
inline void CameraConfig::clear_hfov() {
  hfov_ = 0;
}
inline double CameraConfig::_internal_hfov() const {
  return hfov_;
}
inline double CameraConfig::hfov() const {
  // @@protoc_insertion_point(field_get:pb.CameraConfig.hfov)
  return _internal_hfov();
}
inline void CameraConfig::_internal_set_hfov(double value) {
  
  hfov_ = value;
}
inline void CameraConfig::set_hfov(double value) {
  _internal_set_hfov(value);
  // @@protoc_insertion_point(field_set:pb.CameraConfig.hfov)
}

// double vfov = 2;
inline void CameraConfig::clear_vfov() {
  vfov_ = 0;
}
inline double CameraConfig::_internal_vfov() const {
  return vfov_;
}
inline double CameraConfig::vfov() const {
  // @@protoc_insertion_point(field_get:pb.CameraConfig.vfov)
  return _internal_vfov();
}
inline void CameraConfig::_internal_set_vfov(double value) {
  
  vfov_ = value;
}
inline void CameraConfig::set_vfov(double value) {
  _internal_set_vfov(value);
  // @@protoc_insertion_point(field_set:pb.CameraConfig.vfov)
}

// -------------------------------------------------------------------

// UAVConfig

// .pb.CameraConfig camera_cfg = 1;
inline bool UAVConfig::_internal_has_camera_cfg() const {
  return this != internal_default_instance() && camera_cfg_ != nullptr;
}
inline bool UAVConfig::has_camera_cfg() const {
  return _internal_has_camera_cfg();
}
inline void UAVConfig::clear_camera_cfg() {
  if (GetArenaForAllocation() == nullptr && camera_cfg_ != nullptr) {
    delete camera_cfg_;
  }
  camera_cfg_ = nullptr;
}
inline const ::pb::CameraConfig& UAVConfig::_internal_camera_cfg() const {
  const ::pb::CameraConfig* p = camera_cfg_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::CameraConfig&>(
      ::pb::_CameraConfig_default_instance_);
}
inline const ::pb::CameraConfig& UAVConfig::camera_cfg() const {
  // @@protoc_insertion_point(field_get:pb.UAVConfig.camera_cfg)
  return _internal_camera_cfg();
}
inline void UAVConfig::unsafe_arena_set_allocated_camera_cfg(
    ::pb::CameraConfig* camera_cfg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_cfg_);
  }
  camera_cfg_ = camera_cfg;
  if (camera_cfg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.UAVConfig.camera_cfg)
}
inline ::pb::CameraConfig* UAVConfig::release_camera_cfg() {
  
  ::pb::CameraConfig* temp = camera_cfg_;
  camera_cfg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::CameraConfig* UAVConfig::unsafe_arena_release_camera_cfg() {
  // @@protoc_insertion_point(field_release:pb.UAVConfig.camera_cfg)
  
  ::pb::CameraConfig* temp = camera_cfg_;
  camera_cfg_ = nullptr;
  return temp;
}
inline ::pb::CameraConfig* UAVConfig::_internal_mutable_camera_cfg() {
  
  if (camera_cfg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::CameraConfig>(GetArenaForAllocation());
    camera_cfg_ = p;
  }
  return camera_cfg_;
}
inline ::pb::CameraConfig* UAVConfig::mutable_camera_cfg() {
  ::pb::CameraConfig* _msg = _internal_mutable_camera_cfg();
  // @@protoc_insertion_point(field_mutable:pb.UAVConfig.camera_cfg)
  return _msg;
}
inline void UAVConfig::set_allocated_camera_cfg(::pb::CameraConfig* camera_cfg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete camera_cfg_;
  }
  if (camera_cfg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::CameraConfig>::GetOwningArena(camera_cfg);
    if (message_arena != submessage_arena) {
      camera_cfg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_cfg, submessage_arena);
    }
    
  } else {
    
  }
  camera_cfg_ = camera_cfg;
  // @@protoc_insertion_point(field_set_allocated:pb.UAVConfig.camera_cfg)
}

// float mass = 2;
inline void UAVConfig::clear_mass() {
  mass_ = 0;
}
inline float UAVConfig::_internal_mass() const {
  return mass_;
}
inline float UAVConfig::mass() const {
  // @@protoc_insertion_point(field_get:pb.UAVConfig.mass)
  return _internal_mass();
}
inline void UAVConfig::_internal_set_mass(float value) {
  
  mass_ = value;
}
inline void UAVConfig::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:pb.UAVConfig.mass)
}

// float max_thrust = 3;
inline void UAVConfig::clear_max_thrust() {
  max_thrust_ = 0;
}
inline float UAVConfig::_internal_max_thrust() const {
  return max_thrust_;
}
inline float UAVConfig::max_thrust() const {
  // @@protoc_insertion_point(field_get:pb.UAVConfig.max_thrust)
  return _internal_max_thrust();
}
inline void UAVConfig::_internal_set_max_thrust(float value) {
  
  max_thrust_ = value;
}
inline void UAVConfig::set_max_thrust(float value) {
  _internal_set_max_thrust(value);
  // @@protoc_insertion_point(field_set:pb.UAVConfig.max_thrust)
}

// float max_speed = 4;
inline void UAVConfig::clear_max_speed() {
  max_speed_ = 0;
}
inline float UAVConfig::_internal_max_speed() const {
  return max_speed_;
}
inline float UAVConfig::max_speed() const {
  // @@protoc_insertion_point(field_get:pb.UAVConfig.max_speed)
  return _internal_max_speed();
}
inline void UAVConfig::_internal_set_max_speed(float value) {
  
  max_speed_ = value;
}
inline void UAVConfig::set_max_speed(float value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:pb.UAVConfig.max_speed)
}

// float altitude = 5;
inline void UAVConfig::clear_altitude() {
  altitude_ = 0;
}
inline float UAVConfig::_internal_altitude() const {
  return altitude_;
}
inline float UAVConfig::altitude() const {
  // @@protoc_insertion_point(field_get:pb.UAVConfig.altitude)
  return _internal_altitude();
}
inline void UAVConfig::_internal_set_altitude(float value) {
  
  altitude_ = value;
}
inline void UAVConfig::set_altitude(float value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:pb.UAVConfig.altitude)
}

// float bank_angle = 6;
inline void UAVConfig::clear_bank_angle() {
  bank_angle_ = 0;
}
inline float UAVConfig::_internal_bank_angle() const {
  return bank_angle_;
}
inline float UAVConfig::bank_angle() const {
  // @@protoc_insertion_point(field_get:pb.UAVConfig.bank_angle)
  return _internal_bank_angle();
}
inline void UAVConfig::_internal_set_bank_angle(float value) {
  
  bank_angle_ = value;
}
inline void UAVConfig::set_bank_angle(float value) {
  _internal_set_bank_angle(value);
  // @@protoc_insertion_point(field_set:pb.UAVConfig.bank_angle)
}

// .pb.UAVType uav_type = 7;
inline void UAVConfig::clear_uav_type() {
  uav_type_ = 0;
}
inline ::pb::UAVType UAVConfig::_internal_uav_type() const {
  return static_cast< ::pb::UAVType >(uav_type_);
}
inline ::pb::UAVType UAVConfig::uav_type() const {
  // @@protoc_insertion_point(field_get:pb.UAVConfig.uav_type)
  return _internal_uav_type();
}
inline void UAVConfig::_internal_set_uav_type(::pb::UAVType value) {
  
  uav_type_ = value;
}
inline void UAVConfig::set_uav_type(::pb::UAVType value) {
  _internal_set_uav_type(value);
  // @@protoc_insertion_point(field_set:pb.UAVConfig.uav_type)
}

// -------------------------------------------------------------------

// MobilityModelSimulatorConfig

// .pb.MobilityModel mobmodel = 1;
inline void MobilityModelSimulatorConfig::clear_mobmodel() {
  mobmodel_ = 0;
}
inline ::pb::MobilityModel MobilityModelSimulatorConfig::_internal_mobmodel() const {
  return static_cast< ::pb::MobilityModel >(mobmodel_);
}
inline ::pb::MobilityModel MobilityModelSimulatorConfig::mobmodel() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorConfig.mobmodel)
  return _internal_mobmodel();
}
inline void MobilityModelSimulatorConfig::_internal_set_mobmodel(::pb::MobilityModel value) {
  
  mobmodel_ = value;
}
inline void MobilityModelSimulatorConfig::set_mobmodel(::pb::MobilityModel value) {
  _internal_set_mobmodel(value);
  // @@protoc_insertion_point(field_set:pb.MobilityModelSimulatorConfig.mobmodel)
}

// .pb.CoverageMapConfig coverage_map_cfg = 2;
inline bool MobilityModelSimulatorConfig::_internal_has_coverage_map_cfg() const {
  return this != internal_default_instance() && coverage_map_cfg_ != nullptr;
}
inline bool MobilityModelSimulatorConfig::has_coverage_map_cfg() const {
  return _internal_has_coverage_map_cfg();
}
inline void MobilityModelSimulatorConfig::clear_coverage_map_cfg() {
  if (GetArenaForAllocation() == nullptr && coverage_map_cfg_ != nullptr) {
    delete coverage_map_cfg_;
  }
  coverage_map_cfg_ = nullptr;
}
inline const ::pb::CoverageMapConfig& MobilityModelSimulatorConfig::_internal_coverage_map_cfg() const {
  const ::pb::CoverageMapConfig* p = coverage_map_cfg_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::CoverageMapConfig&>(
      ::pb::_CoverageMapConfig_default_instance_);
}
inline const ::pb::CoverageMapConfig& MobilityModelSimulatorConfig::coverage_map_cfg() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorConfig.coverage_map_cfg)
  return _internal_coverage_map_cfg();
}
inline void MobilityModelSimulatorConfig::unsafe_arena_set_allocated_coverage_map_cfg(
    ::pb::CoverageMapConfig* coverage_map_cfg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coverage_map_cfg_);
  }
  coverage_map_cfg_ = coverage_map_cfg;
  if (coverage_map_cfg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.MobilityModelSimulatorConfig.coverage_map_cfg)
}
inline ::pb::CoverageMapConfig* MobilityModelSimulatorConfig::release_coverage_map_cfg() {
  
  ::pb::CoverageMapConfig* temp = coverage_map_cfg_;
  coverage_map_cfg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::CoverageMapConfig* MobilityModelSimulatorConfig::unsafe_arena_release_coverage_map_cfg() {
  // @@protoc_insertion_point(field_release:pb.MobilityModelSimulatorConfig.coverage_map_cfg)
  
  ::pb::CoverageMapConfig* temp = coverage_map_cfg_;
  coverage_map_cfg_ = nullptr;
  return temp;
}
inline ::pb::CoverageMapConfig* MobilityModelSimulatorConfig::_internal_mutable_coverage_map_cfg() {
  
  if (coverage_map_cfg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::CoverageMapConfig>(GetArenaForAllocation());
    coverage_map_cfg_ = p;
  }
  return coverage_map_cfg_;
}
inline ::pb::CoverageMapConfig* MobilityModelSimulatorConfig::mutable_coverage_map_cfg() {
  ::pb::CoverageMapConfig* _msg = _internal_mutable_coverage_map_cfg();
  // @@protoc_insertion_point(field_mutable:pb.MobilityModelSimulatorConfig.coverage_map_cfg)
  return _msg;
}
inline void MobilityModelSimulatorConfig::set_allocated_coverage_map_cfg(::pb::CoverageMapConfig* coverage_map_cfg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete coverage_map_cfg_;
  }
  if (coverage_map_cfg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::CoverageMapConfig>::GetOwningArena(coverage_map_cfg);
    if (message_arena != submessage_arena) {
      coverage_map_cfg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coverage_map_cfg, submessage_arena);
    }
    
  } else {
    
  }
  coverage_map_cfg_ = coverage_map_cfg;
  // @@protoc_insertion_point(field_set_allocated:pb.MobilityModelSimulatorConfig.coverage_map_cfg)
}

// .pb.UAVConfig uav_cfg = 3;
inline bool MobilityModelSimulatorConfig::_internal_has_uav_cfg() const {
  return this != internal_default_instance() && uav_cfg_ != nullptr;
}
inline bool MobilityModelSimulatorConfig::has_uav_cfg() const {
  return _internal_has_uav_cfg();
}
inline void MobilityModelSimulatorConfig::clear_uav_cfg() {
  if (GetArenaForAllocation() == nullptr && uav_cfg_ != nullptr) {
    delete uav_cfg_;
  }
  uav_cfg_ = nullptr;
}
inline const ::pb::UAVConfig& MobilityModelSimulatorConfig::_internal_uav_cfg() const {
  const ::pb::UAVConfig* p = uav_cfg_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::UAVConfig&>(
      ::pb::_UAVConfig_default_instance_);
}
inline const ::pb::UAVConfig& MobilityModelSimulatorConfig::uav_cfg() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorConfig.uav_cfg)
  return _internal_uav_cfg();
}
inline void MobilityModelSimulatorConfig::unsafe_arena_set_allocated_uav_cfg(
    ::pb::UAVConfig* uav_cfg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uav_cfg_);
  }
  uav_cfg_ = uav_cfg;
  if (uav_cfg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.MobilityModelSimulatorConfig.uav_cfg)
}
inline ::pb::UAVConfig* MobilityModelSimulatorConfig::release_uav_cfg() {
  
  ::pb::UAVConfig* temp = uav_cfg_;
  uav_cfg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::UAVConfig* MobilityModelSimulatorConfig::unsafe_arena_release_uav_cfg() {
  // @@protoc_insertion_point(field_release:pb.MobilityModelSimulatorConfig.uav_cfg)
  
  ::pb::UAVConfig* temp = uav_cfg_;
  uav_cfg_ = nullptr;
  return temp;
}
inline ::pb::UAVConfig* MobilityModelSimulatorConfig::_internal_mutable_uav_cfg() {
  
  if (uav_cfg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::UAVConfig>(GetArenaForAllocation());
    uav_cfg_ = p;
  }
  return uav_cfg_;
}
inline ::pb::UAVConfig* MobilityModelSimulatorConfig::mutable_uav_cfg() {
  ::pb::UAVConfig* _msg = _internal_mutable_uav_cfg();
  // @@protoc_insertion_point(field_mutable:pb.MobilityModelSimulatorConfig.uav_cfg)
  return _msg;
}
inline void MobilityModelSimulatorConfig::set_allocated_uav_cfg(::pb::UAVConfig* uav_cfg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete uav_cfg_;
  }
  if (uav_cfg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pb::UAVConfig>::GetOwningArena(uav_cfg);
    if (message_arena != submessage_arena) {
      uav_cfg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uav_cfg, submessage_arena);
    }
    
  } else {
    
  }
  uav_cfg_ = uav_cfg;
  // @@protoc_insertion_point(field_set_allocated:pb.MobilityModelSimulatorConfig.uav_cfg)
}

// uint32 n_uavs = 4;
inline void MobilityModelSimulatorConfig::clear_n_uavs() {
  n_uavs_ = 0u;
}
inline uint32_t MobilityModelSimulatorConfig::_internal_n_uavs() const {
  return n_uavs_;
}
inline uint32_t MobilityModelSimulatorConfig::n_uavs() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorConfig.n_uavs)
  return _internal_n_uavs();
}
inline void MobilityModelSimulatorConfig::_internal_set_n_uavs(uint32_t value) {
  
  n_uavs_ = value;
}
inline void MobilityModelSimulatorConfig::set_n_uavs(uint32_t value) {
  _internal_set_n_uavs(value);
  // @@protoc_insertion_point(field_set:pb.MobilityModelSimulatorConfig.n_uavs)
}

// -------------------------------------------------------------------

// MobilityModelSimulatorFrameInfo

// .pb.MobilityModelSimulatorState state = 1;
inline void MobilityModelSimulatorFrameInfo::clear_state() {
  state_ = 0;
}
inline ::pb::MobilityModelSimulatorState MobilityModelSimulatorFrameInfo::_internal_state() const {
  return static_cast< ::pb::MobilityModelSimulatorState >(state_);
}
inline ::pb::MobilityModelSimulatorState MobilityModelSimulatorFrameInfo::state() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorFrameInfo.state)
  return _internal_state();
}
inline void MobilityModelSimulatorFrameInfo::_internal_set_state(::pb::MobilityModelSimulatorState value) {
  
  state_ = value;
}
inline void MobilityModelSimulatorFrameInfo::set_state(::pb::MobilityModelSimulatorState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:pb.MobilityModelSimulatorFrameInfo.state)
}

// float simulation_time = 2;
inline void MobilityModelSimulatorFrameInfo::clear_simulation_time() {
  simulation_time_ = 0;
}
inline float MobilityModelSimulatorFrameInfo::_internal_simulation_time() const {
  return simulation_time_;
}
inline float MobilityModelSimulatorFrameInfo::simulation_time() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorFrameInfo.simulation_time)
  return _internal_simulation_time();
}
inline void MobilityModelSimulatorFrameInfo::_internal_set_simulation_time(float value) {
  
  simulation_time_ = value;
}
inline void MobilityModelSimulatorFrameInfo::set_simulation_time(float value) {
  _internal_set_simulation_time(value);
  // @@protoc_insertion_point(field_set:pb.MobilityModelSimulatorFrameInfo.simulation_time)
}

// float coverage_ratio = 3;
inline void MobilityModelSimulatorFrameInfo::clear_coverage_ratio() {
  coverage_ratio_ = 0;
}
inline float MobilityModelSimulatorFrameInfo::_internal_coverage_ratio() const {
  return coverage_ratio_;
}
inline float MobilityModelSimulatorFrameInfo::coverage_ratio() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorFrameInfo.coverage_ratio)
  return _internal_coverage_ratio();
}
inline void MobilityModelSimulatorFrameInfo::_internal_set_coverage_ratio(float value) {
  
  coverage_ratio_ = value;
}
inline void MobilityModelSimulatorFrameInfo::set_coverage_ratio(float value) {
  _internal_set_coverage_ratio(value);
  // @@protoc_insertion_point(field_set:pb.MobilityModelSimulatorFrameInfo.coverage_ratio)
}

// repeated .pb.UAV uavs = 4;
inline int MobilityModelSimulatorFrameInfo::_internal_uavs_size() const {
  return uavs_.size();
}
inline int MobilityModelSimulatorFrameInfo::uavs_size() const {
  return _internal_uavs_size();
}
inline void MobilityModelSimulatorFrameInfo::clear_uavs() {
  uavs_.Clear();
}
inline ::pb::UAV* MobilityModelSimulatorFrameInfo::mutable_uavs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.MobilityModelSimulatorFrameInfo.uavs)
  return uavs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::UAV >*
MobilityModelSimulatorFrameInfo::mutable_uavs() {
  // @@protoc_insertion_point(field_mutable_list:pb.MobilityModelSimulatorFrameInfo.uavs)
  return &uavs_;
}
inline const ::pb::UAV& MobilityModelSimulatorFrameInfo::_internal_uavs(int index) const {
  return uavs_.Get(index);
}
inline const ::pb::UAV& MobilityModelSimulatorFrameInfo::uavs(int index) const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorFrameInfo.uavs)
  return _internal_uavs(index);
}
inline ::pb::UAV* MobilityModelSimulatorFrameInfo::_internal_add_uavs() {
  return uavs_.Add();
}
inline ::pb::UAV* MobilityModelSimulatorFrameInfo::add_uavs() {
  ::pb::UAV* _add = _internal_add_uavs();
  // @@protoc_insertion_point(field_add:pb.MobilityModelSimulatorFrameInfo.uavs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::UAV >&
MobilityModelSimulatorFrameInfo::uavs() const {
  // @@protoc_insertion_point(field_list:pb.MobilityModelSimulatorFrameInfo.uavs)
  return uavs_;
}

// -------------------------------------------------------------------

// MobilityModelSimulatorApproxMap

// uint32 rows = 1;
inline void MobilityModelSimulatorApproxMap::clear_rows() {
  rows_ = 0u;
}
inline uint32_t MobilityModelSimulatorApproxMap::_internal_rows() const {
  return rows_;
}
inline uint32_t MobilityModelSimulatorApproxMap::rows() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorApproxMap.rows)
  return _internal_rows();
}
inline void MobilityModelSimulatorApproxMap::_internal_set_rows(uint32_t value) {
  
  rows_ = value;
}
inline void MobilityModelSimulatorApproxMap::set_rows(uint32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:pb.MobilityModelSimulatorApproxMap.rows)
}

// uint32 cols = 2;
inline void MobilityModelSimulatorApproxMap::clear_cols() {
  cols_ = 0u;
}
inline uint32_t MobilityModelSimulatorApproxMap::_internal_cols() const {
  return cols_;
}
inline uint32_t MobilityModelSimulatorApproxMap::cols() const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorApproxMap.cols)
  return _internal_cols();
}
inline void MobilityModelSimulatorApproxMap::_internal_set_cols(uint32_t value) {
  
  cols_ = value;
}
inline void MobilityModelSimulatorApproxMap::set_cols(uint32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:pb.MobilityModelSimulatorApproxMap.cols)
}

// repeated uint32 zones = 3;
inline int MobilityModelSimulatorApproxMap::_internal_zones_size() const {
  return zones_.size();
}
inline int MobilityModelSimulatorApproxMap::zones_size() const {
  return _internal_zones_size();
}
inline void MobilityModelSimulatorApproxMap::clear_zones() {
  zones_.Clear();
}
inline uint32_t MobilityModelSimulatorApproxMap::_internal_zones(int index) const {
  return zones_.Get(index);
}
inline uint32_t MobilityModelSimulatorApproxMap::zones(int index) const {
  // @@protoc_insertion_point(field_get:pb.MobilityModelSimulatorApproxMap.zones)
  return _internal_zones(index);
}
inline void MobilityModelSimulatorApproxMap::set_zones(int index, uint32_t value) {
  zones_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.MobilityModelSimulatorApproxMap.zones)
}
inline void MobilityModelSimulatorApproxMap::_internal_add_zones(uint32_t value) {
  zones_.Add(value);
}
inline void MobilityModelSimulatorApproxMap::add_zones(uint32_t value) {
  _internal_add_zones(value);
  // @@protoc_insertion_point(field_add:pb.MobilityModelSimulatorApproxMap.zones)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MobilityModelSimulatorApproxMap::_internal_zones() const {
  return zones_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MobilityModelSimulatorApproxMap::zones() const {
  // @@protoc_insertion_point(field_list:pb.MobilityModelSimulatorApproxMap.zones)
  return _internal_zones();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MobilityModelSimulatorApproxMap::_internal_mutable_zones() {
  return &zones_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MobilityModelSimulatorApproxMap::mutable_zones() {
  // @@protoc_insertion_point(field_mutable_list:pb.MobilityModelSimulatorApproxMap.zones)
  return _internal_mutable_zones();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::UAVType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::UAVType>() {
  return ::pb::UAVType_descriptor();
}
template <> struct is_proto_enum< ::pb::MobilityModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::MobilityModel>() {
  return ::pb::MobilityModel_descriptor();
}
template <> struct is_proto_enum< ::pb::MobilityModelSimulatorState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::MobilityModelSimulatorState>() {
  return ::pb::MobilityModelSimulatorState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fmobmodel_2dsimulator_2eproto
