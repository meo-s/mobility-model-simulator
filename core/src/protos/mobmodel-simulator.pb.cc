// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/mobmodel-simulator.proto

#include "protos/mobmodel-simulator.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace pb {
constexpr Vec2f::Vec2f(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0){}
struct Vec2fDefaultTypeInternal {
  constexpr Vec2fDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Vec2fDefaultTypeInternal() {}
  union {
    Vec2f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Vec2fDefaultTypeInternal _Vec2f_default_instance_;
constexpr Vec3f::Vec3f(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0)
  , z_(0){}
struct Vec3fDefaultTypeInternal {
  constexpr Vec3fDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Vec3fDefaultTypeInternal() {}
  union {
    Vec3f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Vec3fDefaultTypeInternal _Vec3f_default_instance_;
constexpr UAV::UAV(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : position_(nullptr)
  , destination_(nullptr)
  , index_(0u){}
struct UAVDefaultTypeInternal {
  constexpr UAVDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UAVDefaultTypeInternal() {}
  union {
    UAV _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UAVDefaultTypeInternal _UAV_default_instance_;
constexpr CoverageMapConfig::CoverageMapConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : map_height_(0)
  , map_width_(0)
  , cell_size_(0){}
struct CoverageMapConfigDefaultTypeInternal {
  constexpr CoverageMapConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CoverageMapConfigDefaultTypeInternal() {}
  union {
    CoverageMapConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CoverageMapConfigDefaultTypeInternal _CoverageMapConfig_default_instance_;
constexpr CameraConfig::CameraConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hfov_(0)
  , vfov_(0){}
struct CameraConfigDefaultTypeInternal {
  constexpr CameraConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CameraConfigDefaultTypeInternal() {}
  union {
    CameraConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CameraConfigDefaultTypeInternal _CameraConfig_default_instance_;
constexpr UAVConfig::UAVConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : camera_cfg_(nullptr)
  , mass_(0)
  , max_thrust_(0)
  , max_speed_(0)
  , altitude_(0)
  , bank_angle_(0)
  , uav_type_(0)
{}
struct UAVConfigDefaultTypeInternal {
  constexpr UAVConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UAVConfigDefaultTypeInternal() {}
  union {
    UAVConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UAVConfigDefaultTypeInternal _UAVConfig_default_instance_;
constexpr MobilityModelSimulatorConfig::MobilityModelSimulatorConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : coverage_map_cfg_(nullptr)
  , uav_cfg_(nullptr)
  , mobmodel_(0)

  , n_uavs_(0u){}
struct MobilityModelSimulatorConfigDefaultTypeInternal {
  constexpr MobilityModelSimulatorConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MobilityModelSimulatorConfigDefaultTypeInternal() {}
  union {
    MobilityModelSimulatorConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MobilityModelSimulatorConfigDefaultTypeInternal _MobilityModelSimulatorConfig_default_instance_;
constexpr MobilityModelSimulatorFrameInfo::MobilityModelSimulatorFrameInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : uavs_()
  , state_(0)

  , simulation_time_(0)
  , coverage_ratio_(0){}
struct MobilityModelSimulatorFrameInfoDefaultTypeInternal {
  constexpr MobilityModelSimulatorFrameInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MobilityModelSimulatorFrameInfoDefaultTypeInternal() {}
  union {
    MobilityModelSimulatorFrameInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MobilityModelSimulatorFrameInfoDefaultTypeInternal _MobilityModelSimulatorFrameInfo_default_instance_;
constexpr MobilityModelSimulatorApproxMap::MobilityModelSimulatorApproxMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : zones_()
  , _zones_cached_byte_size_(0)
  , rows_(0u)
  , cols_(0u){}
struct MobilityModelSimulatorApproxMapDefaultTypeInternal {
  constexpr MobilityModelSimulatorApproxMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MobilityModelSimulatorApproxMapDefaultTypeInternal() {}
  union {
    MobilityModelSimulatorApproxMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MobilityModelSimulatorApproxMapDefaultTypeInternal _MobilityModelSimulatorApproxMap_default_instance_;
}  // namespace pb
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[9];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_protos_2fmobmodel_2dsimulator_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_protos_2fmobmodel_2dsimulator_2eproto = nullptr;

const uint32_t TableStruct_protos_2fmobmodel_2dsimulator_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::Vec2f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::Vec2f, x_),
  PROTOBUF_FIELD_OFFSET(::pb::Vec2f, y_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::Vec3f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::Vec3f, x_),
  PROTOBUF_FIELD_OFFSET(::pb::Vec3f, y_),
  PROTOBUF_FIELD_OFFSET(::pb::Vec3f, z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::UAV, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::UAV, index_),
  PROTOBUF_FIELD_OFFSET(::pb::UAV, position_),
  PROTOBUF_FIELD_OFFSET(::pb::UAV, destination_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::CoverageMapConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::CoverageMapConfig, map_height_),
  PROTOBUF_FIELD_OFFSET(::pb::CoverageMapConfig, map_width_),
  PROTOBUF_FIELD_OFFSET(::pb::CoverageMapConfig, cell_size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::CameraConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::CameraConfig, hfov_),
  PROTOBUF_FIELD_OFFSET(::pb::CameraConfig, vfov_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::UAVConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::UAVConfig, camera_cfg_),
  PROTOBUF_FIELD_OFFSET(::pb::UAVConfig, mass_),
  PROTOBUF_FIELD_OFFSET(::pb::UAVConfig, max_thrust_),
  PROTOBUF_FIELD_OFFSET(::pb::UAVConfig, max_speed_),
  PROTOBUF_FIELD_OFFSET(::pb::UAVConfig, altitude_),
  PROTOBUF_FIELD_OFFSET(::pb::UAVConfig, bank_angle_),
  PROTOBUF_FIELD_OFFSET(::pb::UAVConfig, uav_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorConfig, mobmodel_),
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorConfig, coverage_map_cfg_),
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorConfig, uav_cfg_),
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorConfig, n_uavs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorFrameInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorFrameInfo, state_),
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorFrameInfo, simulation_time_),
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorFrameInfo, coverage_ratio_),
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorFrameInfo, uavs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorApproxMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorApproxMap, rows_),
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorApproxMap, cols_),
  PROTOBUF_FIELD_OFFSET(::pb::MobilityModelSimulatorApproxMap, zones_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::pb::Vec2f)},
  { 8, -1, -1, sizeof(::pb::Vec3f)},
  { 17, -1, -1, sizeof(::pb::UAV)},
  { 26, -1, -1, sizeof(::pb::CoverageMapConfig)},
  { 35, -1, -1, sizeof(::pb::CameraConfig)},
  { 43, -1, -1, sizeof(::pb::UAVConfig)},
  { 56, -1, -1, sizeof(::pb::MobilityModelSimulatorConfig)},
  { 66, -1, -1, sizeof(::pb::MobilityModelSimulatorFrameInfo)},
  { 76, -1, -1, sizeof(::pb::MobilityModelSimulatorApproxMap)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_Vec2f_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_Vec3f_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_UAV_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_CoverageMapConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_CameraConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_UAVConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_MobilityModelSimulatorConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_MobilityModelSimulatorFrameInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pb::_MobilityModelSimulatorApproxMap_default_instance_),
};

const char descriptor_table_protodef_protos_2fmobmodel_2dsimulator_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\037protos/mobmodel-simulator.proto\022\002pb\032\033g"
  "oogle/protobuf/empty.proto\032\036google/proto"
  "buf/wrappers.proto\"\035\n\005Vec2f\022\t\n\001x\030\001 \001(\002\022\t"
  "\n\001y\030\002 \001(\002\"(\n\005Vec3f\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002"
  "\022\t\n\001z\030\003 \001(\002\"Q\n\003UAV\022\r\n\005index\030\001 \001(\r\022\033\n\010pos"
  "ition\030\002 \001(\0132\t.pb.Vec3f\022\036\n\013destination\030\003 "
  "\001(\0132\t.pb.Vec2f\"M\n\021CoverageMapConfig\022\022\n\nm"
  "ap_height\030\001 \001(\001\022\021\n\tmap_width\030\002 \001(\001\022\021\n\tce"
  "ll_size\030\003 \001(\001\"*\n\014CameraConfig\022\014\n\004hfov\030\001 "
  "\001(\001\022\014\n\004vfov\030\002 \001(\001\"\253\001\n\tUAVConfig\022$\n\ncamer"
  "a_cfg\030\001 \001(\0132\020.pb.CameraConfig\022\014\n\004mass\030\002 "
  "\001(\002\022\022\n\nmax_thrust\030\003 \001(\002\022\021\n\tmax_speed\030\004 \001"
  "(\002\022\020\n\010altitude\030\005 \001(\002\022\022\n\nbank_angle\030\006 \001(\002"
  "\022\035\n\010uav_type\030\007 \001(\0162\013.pb.UAVType\"\244\001\n\034Mobi"
  "lityModelSimulatorConfig\022#\n\010mobmodel\030\001 \001"
  "(\0162\021.pb.MobilityModel\022/\n\020coverage_map_cf"
  "g\030\002 \001(\0132\025.pb.CoverageMapConfig\022\036\n\007uav_cf"
  "g\030\003 \001(\0132\r.pb.UAVConfig\022\016\n\006n_uavs\030\004 \001(\r\"\231"
  "\001\n\037MobilityModelSimulatorFrameInfo\022.\n\005st"
  "ate\030\001 \001(\0162\037.pb.MobilityModelSimulatorSta"
  "te\022\027\n\017simulation_time\030\002 \001(\002\022\026\n\016coverage_"
  "ratio\030\003 \001(\002\022\025\n\004uavs\030\004 \003(\0132\007.pb.UAV\"L\n\037Mo"
  "bilityModelSimulatorApproxMap\022\014\n\004rows\030\001 "
  "\001(\r\022\014\n\004cols\030\002 \001(\r\022\r\n\005zones\030\003 \003(\r*@\n\007UAVT"
  "ype\022\024\n\020UNKNOWN_UAV_TYPE\020\000\022\017\n\013ROTARY_WING"
  "\020\001\022\016\n\nFIXED_WING\020\002*@\n\rMobilityModel\022\032\n\026U"
  "NKNOWN_MOBILITY_MODEL\020\000\022\023\n\017RANDOM_WAYPOI"
  "NT\020\001*4\n\033MobilityModelSimulatorState\022\010\n\004I"
  "DLE\020\000\022\013\n\007RUNNING\020\0012\300\003\n\035MobilityModelSimu"
  "latorService\022G\n\017isSimulatorIdle\022\026.google"
  ".protobuf.Empty\032\032.google.protobuf.BoolVa"
  "lue\"\000\022W\n\025tryStartingSimulation\022 .pb.Mobi"
  "lityModelSimulatorConfig\032\032.google.protob"
  "uf.BoolValue\"\000\022M\n\025tryStoppingSimulation\022"
  "\026.google.protobuf.Empty\032\032.google.protobu"
  "f.BoolValue\"\000\022V\n\025getSimulatorFrameInfo\022\026"
  ".google.protobuf.Empty\032#.pb.MobilityMode"
  "lSimulatorFrameInfo\"\000\022V\n\025getSimulatorApp"
  "roxMap\022\026.google.protobuf.Empty\032#.pb.Mobi"
  "lityModelSimulatorApproxMap\"\000b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_deps[2] = {
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2fwrappers_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fmobmodel_2dsimulator_2eproto = {
  false, false, 1597, descriptor_table_protodef_protos_2fmobmodel_2dsimulator_2eproto, "protos/mobmodel-simulator.proto", 
  &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once, descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_deps, 2, 9,
  schemas, file_default_instances, TableStruct_protos_2fmobmodel_2dsimulator_2eproto::offsets,
  file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto, file_level_enum_descriptors_protos_2fmobmodel_2dsimulator_2eproto, file_level_service_descriptors_protos_2fmobmodel_2dsimulator_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter() {
  return &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_protos_2fmobmodel_2dsimulator_2eproto(&descriptor_table_protos_2fmobmodel_2dsimulator_2eproto);
namespace pb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UAVType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protos_2fmobmodel_2dsimulator_2eproto);
  return file_level_enum_descriptors_protos_2fmobmodel_2dsimulator_2eproto[0];
}
bool UAVType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MobilityModel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protos_2fmobmodel_2dsimulator_2eproto);
  return file_level_enum_descriptors_protos_2fmobmodel_2dsimulator_2eproto[1];
}
bool MobilityModel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MobilityModelSimulatorState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protos_2fmobmodel_2dsimulator_2eproto);
  return file_level_enum_descriptors_protos_2fmobmodel_2dsimulator_2eproto[2];
}
bool MobilityModelSimulatorState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Vec2f::_Internal {
 public:
};

Vec2f::Vec2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.Vec2f)
}
Vec2f::Vec2f(const Vec2f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:pb.Vec2f)
}

inline void Vec2f::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

Vec2f::~Vec2f() {
  // @@protoc_insertion_point(destructor:pb.Vec2f)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Vec2f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vec2f::ArenaDtor(void* object) {
  Vec2f* _this = reinterpret_cast< Vec2f* >(object);
  (void)_this;
}
void Vec2f::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Vec2f::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Vec2f::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.Vec2f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vec2f::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vec2f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.Vec2f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.Vec2f)
  return target;
}

size_t Vec2f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.Vec2f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vec2f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Vec2f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vec2f::GetClassData() const { return &_class_data_; }

void Vec2f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Vec2f *>(to)->MergeFrom(
      static_cast<const Vec2f &>(from));
}


void Vec2f::MergeFrom(const Vec2f& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.Vec2f)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _internal_set_y(from._internal_y());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vec2f::CopyFrom(const Vec2f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.Vec2f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec2f::IsInitialized() const {
  return true;
}

void Vec2f::InternalSwap(Vec2f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vec2f, y_)
      + sizeof(Vec2f::y_)
      - PROTOBUF_FIELD_OFFSET(Vec2f, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vec2f::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[0]);
}

// ===================================================================

class Vec3f::_Internal {
 public:
};

Vec3f::Vec3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.Vec3f)
}
Vec3f::Vec3f(const Vec3f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:pb.Vec3f)
}

inline void Vec3f::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Vec3f::~Vec3f() {
  // @@protoc_insertion_point(destructor:pb.Vec3f)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Vec3f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vec3f::ArenaDtor(void* object) {
  Vec3f* _this = reinterpret_cast< Vec3f* >(object);
  (void)_this;
}
void Vec3f::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Vec3f::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Vec3f::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.Vec3f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vec3f::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vec3f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.Vec3f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.Vec3f)
  return target;
}

size_t Vec3f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.Vec3f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vec3f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Vec3f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vec3f::GetClassData() const { return &_class_data_; }

void Vec3f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Vec3f *>(to)->MergeFrom(
      static_cast<const Vec3f &>(from));
}


void Vec3f::MergeFrom(const Vec3f& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.Vec3f)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _internal_set_z(from._internal_z());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vec3f::CopyFrom(const Vec3f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.Vec3f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec3f::IsInitialized() const {
  return true;
}

void Vec3f::InternalSwap(Vec3f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vec3f, z_)
      + sizeof(Vec3f::z_)
      - PROTOBUF_FIELD_OFFSET(Vec3f, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vec3f::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[1]);
}

// ===================================================================

class UAV::_Internal {
 public:
  static const ::pb::Vec3f& position(const UAV* msg);
  static const ::pb::Vec2f& destination(const UAV* msg);
};

const ::pb::Vec3f&
UAV::_Internal::position(const UAV* msg) {
  return *msg->position_;
}
const ::pb::Vec2f&
UAV::_Internal::destination(const UAV* msg) {
  return *msg->destination_;
}
UAV::UAV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.UAV)
}
UAV::UAV(const UAV& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    position_ = new ::pb::Vec3f(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from._internal_has_destination()) {
    destination_ = new ::pb::Vec2f(*from.destination_);
  } else {
    destination_ = nullptr;
  }
  index_ = from.index_;
  // @@protoc_insertion_point(copy_constructor:pb.UAV)
}

inline void UAV::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&position_)) + sizeof(index_));
}

UAV::~UAV() {
  // @@protoc_insertion_point(destructor:pb.UAV)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UAV::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete destination_;
}

void UAV::ArenaDtor(void* object) {
  UAV* _this = reinterpret_cast< UAV* >(object);
  (void)_this;
}
void UAV::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UAV::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UAV::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.UAV)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && destination_ != nullptr) {
    delete destination_;
  }
  destination_ = nullptr;
  index_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UAV::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .pb.Vec3f position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .pb.Vec2f destination = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_destination(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UAV::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.UAV)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 index = 1;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_index(), target);
  }

  // .pb.Vec3f position = 2;
  if (this->_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::position(this), target, stream);
  }

  // .pb.Vec2f destination = 3;
  if (this->_internal_has_destination()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::destination(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.UAV)
  return target;
}

size_t UAV::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.UAV)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pb.Vec3f position = 2;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // .pb.Vec2f destination = 3;
  if (this->_internal_has_destination()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *destination_);
  }

  // uint32 index = 1;
  if (this->_internal_index() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UAV::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UAV::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UAV::GetClassData() const { return &_class_data_; }

void UAV::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UAV *>(to)->MergeFrom(
      static_cast<const UAV &>(from));
}


void UAV::MergeFrom(const UAV& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.UAV)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_position()) {
    _internal_mutable_position()->::pb::Vec3f::MergeFrom(from._internal_position());
  }
  if (from._internal_has_destination()) {
    _internal_mutable_destination()->::pb::Vec2f::MergeFrom(from._internal_destination());
  }
  if (from._internal_index() != 0) {
    _internal_set_index(from._internal_index());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UAV::CopyFrom(const UAV& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.UAV)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAV::IsInitialized() const {
  return true;
}

void UAV::InternalSwap(UAV* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UAV, index_)
      + sizeof(UAV::index_)
      - PROTOBUF_FIELD_OFFSET(UAV, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UAV::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[2]);
}

// ===================================================================

class CoverageMapConfig::_Internal {
 public:
};

CoverageMapConfig::CoverageMapConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.CoverageMapConfig)
}
CoverageMapConfig::CoverageMapConfig(const CoverageMapConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&map_height_, &from.map_height_,
    static_cast<size_t>(reinterpret_cast<char*>(&cell_size_) -
    reinterpret_cast<char*>(&map_height_)) + sizeof(cell_size_));
  // @@protoc_insertion_point(copy_constructor:pb.CoverageMapConfig)
}

inline void CoverageMapConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&map_height_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cell_size_) -
    reinterpret_cast<char*>(&map_height_)) + sizeof(cell_size_));
}

CoverageMapConfig::~CoverageMapConfig() {
  // @@protoc_insertion_point(destructor:pb.CoverageMapConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CoverageMapConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CoverageMapConfig::ArenaDtor(void* object) {
  CoverageMapConfig* _this = reinterpret_cast< CoverageMapConfig* >(object);
  (void)_this;
}
void CoverageMapConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CoverageMapConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoverageMapConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.CoverageMapConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&map_height_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cell_size_) -
      reinterpret_cast<char*>(&map_height_)) + sizeof(cell_size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CoverageMapConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double map_height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          map_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double map_width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          map_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double cell_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          cell_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoverageMapConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.CoverageMapConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double map_height = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_map_height = this->_internal_map_height();
  uint64_t raw_map_height;
  memcpy(&raw_map_height, &tmp_map_height, sizeof(tmp_map_height));
  if (raw_map_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_map_height(), target);
  }

  // double map_width = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_map_width = this->_internal_map_width();
  uint64_t raw_map_width;
  memcpy(&raw_map_width, &tmp_map_width, sizeof(tmp_map_width));
  if (raw_map_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_map_width(), target);
  }

  // double cell_size = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cell_size = this->_internal_cell_size();
  uint64_t raw_cell_size;
  memcpy(&raw_cell_size, &tmp_cell_size, sizeof(tmp_cell_size));
  if (raw_cell_size != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_cell_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.CoverageMapConfig)
  return target;
}

size_t CoverageMapConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.CoverageMapConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double map_height = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_map_height = this->_internal_map_height();
  uint64_t raw_map_height;
  memcpy(&raw_map_height, &tmp_map_height, sizeof(tmp_map_height));
  if (raw_map_height != 0) {
    total_size += 1 + 8;
  }

  // double map_width = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_map_width = this->_internal_map_width();
  uint64_t raw_map_width;
  memcpy(&raw_map_width, &tmp_map_width, sizeof(tmp_map_width));
  if (raw_map_width != 0) {
    total_size += 1 + 8;
  }

  // double cell_size = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cell_size = this->_internal_cell_size();
  uint64_t raw_cell_size;
  memcpy(&raw_cell_size, &tmp_cell_size, sizeof(tmp_cell_size));
  if (raw_cell_size != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CoverageMapConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CoverageMapConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CoverageMapConfig::GetClassData() const { return &_class_data_; }

void CoverageMapConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CoverageMapConfig *>(to)->MergeFrom(
      static_cast<const CoverageMapConfig &>(from));
}


void CoverageMapConfig::MergeFrom(const CoverageMapConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.CoverageMapConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_map_height = from._internal_map_height();
  uint64_t raw_map_height;
  memcpy(&raw_map_height, &tmp_map_height, sizeof(tmp_map_height));
  if (raw_map_height != 0) {
    _internal_set_map_height(from._internal_map_height());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_map_width = from._internal_map_width();
  uint64_t raw_map_width;
  memcpy(&raw_map_width, &tmp_map_width, sizeof(tmp_map_width));
  if (raw_map_width != 0) {
    _internal_set_map_width(from._internal_map_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cell_size = from._internal_cell_size();
  uint64_t raw_cell_size;
  memcpy(&raw_cell_size, &tmp_cell_size, sizeof(tmp_cell_size));
  if (raw_cell_size != 0) {
    _internal_set_cell_size(from._internal_cell_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CoverageMapConfig::CopyFrom(const CoverageMapConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.CoverageMapConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoverageMapConfig::IsInitialized() const {
  return true;
}

void CoverageMapConfig::InternalSwap(CoverageMapConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CoverageMapConfig, cell_size_)
      + sizeof(CoverageMapConfig::cell_size_)
      - PROTOBUF_FIELD_OFFSET(CoverageMapConfig, map_height_)>(
          reinterpret_cast<char*>(&map_height_),
          reinterpret_cast<char*>(&other->map_height_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CoverageMapConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[3]);
}

// ===================================================================

class CameraConfig::_Internal {
 public:
};

CameraConfig::CameraConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.CameraConfig)
}
CameraConfig::CameraConfig(const CameraConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&hfov_, &from.hfov_,
    static_cast<size_t>(reinterpret_cast<char*>(&vfov_) -
    reinterpret_cast<char*>(&hfov_)) + sizeof(vfov_));
  // @@protoc_insertion_point(copy_constructor:pb.CameraConfig)
}

inline void CameraConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hfov_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&vfov_) -
    reinterpret_cast<char*>(&hfov_)) + sizeof(vfov_));
}

CameraConfig::~CameraConfig() {
  // @@protoc_insertion_point(destructor:pb.CameraConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CameraConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CameraConfig::ArenaDtor(void* object) {
  CameraConfig* _this = reinterpret_cast< CameraConfig* >(object);
  (void)_this;
}
void CameraConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CameraConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CameraConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.CameraConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&hfov_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&vfov_) -
      reinterpret_cast<char*>(&hfov_)) + sizeof(vfov_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CameraConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double hfov = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          hfov_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double vfov = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          vfov_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CameraConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.CameraConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double hfov = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_hfov = this->_internal_hfov();
  uint64_t raw_hfov;
  memcpy(&raw_hfov, &tmp_hfov, sizeof(tmp_hfov));
  if (raw_hfov != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_hfov(), target);
  }

  // double vfov = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_vfov = this->_internal_vfov();
  uint64_t raw_vfov;
  memcpy(&raw_vfov, &tmp_vfov, sizeof(tmp_vfov));
  if (raw_vfov != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_vfov(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.CameraConfig)
  return target;
}

size_t CameraConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.CameraConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double hfov = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_hfov = this->_internal_hfov();
  uint64_t raw_hfov;
  memcpy(&raw_hfov, &tmp_hfov, sizeof(tmp_hfov));
  if (raw_hfov != 0) {
    total_size += 1 + 8;
  }

  // double vfov = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_vfov = this->_internal_vfov();
  uint64_t raw_vfov;
  memcpy(&raw_vfov, &tmp_vfov, sizeof(tmp_vfov));
  if (raw_vfov != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CameraConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CameraConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CameraConfig::GetClassData() const { return &_class_data_; }

void CameraConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CameraConfig *>(to)->MergeFrom(
      static_cast<const CameraConfig &>(from));
}


void CameraConfig::MergeFrom(const CameraConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.CameraConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_hfov = from._internal_hfov();
  uint64_t raw_hfov;
  memcpy(&raw_hfov, &tmp_hfov, sizeof(tmp_hfov));
  if (raw_hfov != 0) {
    _internal_set_hfov(from._internal_hfov());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_vfov = from._internal_vfov();
  uint64_t raw_vfov;
  memcpy(&raw_vfov, &tmp_vfov, sizeof(tmp_vfov));
  if (raw_vfov != 0) {
    _internal_set_vfov(from._internal_vfov());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CameraConfig::CopyFrom(const CameraConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.CameraConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraConfig::IsInitialized() const {
  return true;
}

void CameraConfig::InternalSwap(CameraConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CameraConfig, vfov_)
      + sizeof(CameraConfig::vfov_)
      - PROTOBUF_FIELD_OFFSET(CameraConfig, hfov_)>(
          reinterpret_cast<char*>(&hfov_),
          reinterpret_cast<char*>(&other->hfov_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CameraConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[4]);
}

// ===================================================================

class UAVConfig::_Internal {
 public:
  static const ::pb::CameraConfig& camera_cfg(const UAVConfig* msg);
};

const ::pb::CameraConfig&
UAVConfig::_Internal::camera_cfg(const UAVConfig* msg) {
  return *msg->camera_cfg_;
}
UAVConfig::UAVConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.UAVConfig)
}
UAVConfig::UAVConfig(const UAVConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_camera_cfg()) {
    camera_cfg_ = new ::pb::CameraConfig(*from.camera_cfg_);
  } else {
    camera_cfg_ = nullptr;
  }
  ::memcpy(&mass_, &from.mass_,
    static_cast<size_t>(reinterpret_cast<char*>(&uav_type_) -
    reinterpret_cast<char*>(&mass_)) + sizeof(uav_type_));
  // @@protoc_insertion_point(copy_constructor:pb.UAVConfig)
}

inline void UAVConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&camera_cfg_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&uav_type_) -
    reinterpret_cast<char*>(&camera_cfg_)) + sizeof(uav_type_));
}

UAVConfig::~UAVConfig() {
  // @@protoc_insertion_point(destructor:pb.UAVConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UAVConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete camera_cfg_;
}

void UAVConfig::ArenaDtor(void* object) {
  UAVConfig* _this = reinterpret_cast< UAVConfig* >(object);
  (void)_this;
}
void UAVConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UAVConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UAVConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.UAVConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && camera_cfg_ != nullptr) {
    delete camera_cfg_;
  }
  camera_cfg_ = nullptr;
  ::memset(&mass_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&uav_type_) -
      reinterpret_cast<char*>(&mass_)) + sizeof(uav_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UAVConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .pb.CameraConfig camera_cfg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera_cfg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float mass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float max_thrust = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          max_thrust_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float max_speed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          max_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float altitude = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          altitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float bank_angle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          bank_angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .pb.UAVType uav_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_uav_type(static_cast<::pb::UAVType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UAVConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.UAVConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .pb.CameraConfig camera_cfg = 1;
  if (this->_internal_has_camera_cfg()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::camera_cfg(this), target, stream);
  }

  // float mass = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = this->_internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_mass(), target);
  }

  // float max_thrust = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_thrust = this->_internal_max_thrust();
  uint32_t raw_max_thrust;
  memcpy(&raw_max_thrust, &tmp_max_thrust, sizeof(tmp_max_thrust));
  if (raw_max_thrust != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_max_thrust(), target);
  }

  // float max_speed = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_speed = this->_internal_max_speed();
  uint32_t raw_max_speed;
  memcpy(&raw_max_speed, &tmp_max_speed, sizeof(tmp_max_speed));
  if (raw_max_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_max_speed(), target);
  }

  // float altitude = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_altitude = this->_internal_altitude();
  uint32_t raw_altitude;
  memcpy(&raw_altitude, &tmp_altitude, sizeof(tmp_altitude));
  if (raw_altitude != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_altitude(), target);
  }

  // float bank_angle = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bank_angle = this->_internal_bank_angle();
  uint32_t raw_bank_angle;
  memcpy(&raw_bank_angle, &tmp_bank_angle, sizeof(tmp_bank_angle));
  if (raw_bank_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_bank_angle(), target);
  }

  // .pb.UAVType uav_type = 7;
  if (this->_internal_uav_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_uav_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.UAVConfig)
  return target;
}

size_t UAVConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.UAVConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pb.CameraConfig camera_cfg = 1;
  if (this->_internal_has_camera_cfg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *camera_cfg_);
  }

  // float mass = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = this->_internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    total_size += 1 + 4;
  }

  // float max_thrust = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_thrust = this->_internal_max_thrust();
  uint32_t raw_max_thrust;
  memcpy(&raw_max_thrust, &tmp_max_thrust, sizeof(tmp_max_thrust));
  if (raw_max_thrust != 0) {
    total_size += 1 + 4;
  }

  // float max_speed = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_speed = this->_internal_max_speed();
  uint32_t raw_max_speed;
  memcpy(&raw_max_speed, &tmp_max_speed, sizeof(tmp_max_speed));
  if (raw_max_speed != 0) {
    total_size += 1 + 4;
  }

  // float altitude = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_altitude = this->_internal_altitude();
  uint32_t raw_altitude;
  memcpy(&raw_altitude, &tmp_altitude, sizeof(tmp_altitude));
  if (raw_altitude != 0) {
    total_size += 1 + 4;
  }

  // float bank_angle = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bank_angle = this->_internal_bank_angle();
  uint32_t raw_bank_angle;
  memcpy(&raw_bank_angle, &tmp_bank_angle, sizeof(tmp_bank_angle));
  if (raw_bank_angle != 0) {
    total_size += 1 + 4;
  }

  // .pb.UAVType uav_type = 7;
  if (this->_internal_uav_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_uav_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UAVConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UAVConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UAVConfig::GetClassData() const { return &_class_data_; }

void UAVConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UAVConfig *>(to)->MergeFrom(
      static_cast<const UAVConfig &>(from));
}


void UAVConfig::MergeFrom(const UAVConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.UAVConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_camera_cfg()) {
    _internal_mutable_camera_cfg()->::pb::CameraConfig::MergeFrom(from._internal_camera_cfg());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mass = from._internal_mass();
  uint32_t raw_mass;
  memcpy(&raw_mass, &tmp_mass, sizeof(tmp_mass));
  if (raw_mass != 0) {
    _internal_set_mass(from._internal_mass());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_thrust = from._internal_max_thrust();
  uint32_t raw_max_thrust;
  memcpy(&raw_max_thrust, &tmp_max_thrust, sizeof(tmp_max_thrust));
  if (raw_max_thrust != 0) {
    _internal_set_max_thrust(from._internal_max_thrust());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_max_speed = from._internal_max_speed();
  uint32_t raw_max_speed;
  memcpy(&raw_max_speed, &tmp_max_speed, sizeof(tmp_max_speed));
  if (raw_max_speed != 0) {
    _internal_set_max_speed(from._internal_max_speed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_altitude = from._internal_altitude();
  uint32_t raw_altitude;
  memcpy(&raw_altitude, &tmp_altitude, sizeof(tmp_altitude));
  if (raw_altitude != 0) {
    _internal_set_altitude(from._internal_altitude());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bank_angle = from._internal_bank_angle();
  uint32_t raw_bank_angle;
  memcpy(&raw_bank_angle, &tmp_bank_angle, sizeof(tmp_bank_angle));
  if (raw_bank_angle != 0) {
    _internal_set_bank_angle(from._internal_bank_angle());
  }
  if (from._internal_uav_type() != 0) {
    _internal_set_uav_type(from._internal_uav_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UAVConfig::CopyFrom(const UAVConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.UAVConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UAVConfig::IsInitialized() const {
  return true;
}

void UAVConfig::InternalSwap(UAVConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UAVConfig, uav_type_)
      + sizeof(UAVConfig::uav_type_)
      - PROTOBUF_FIELD_OFFSET(UAVConfig, camera_cfg_)>(
          reinterpret_cast<char*>(&camera_cfg_),
          reinterpret_cast<char*>(&other->camera_cfg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UAVConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[5]);
}

// ===================================================================

class MobilityModelSimulatorConfig::_Internal {
 public:
  static const ::pb::CoverageMapConfig& coverage_map_cfg(const MobilityModelSimulatorConfig* msg);
  static const ::pb::UAVConfig& uav_cfg(const MobilityModelSimulatorConfig* msg);
};

const ::pb::CoverageMapConfig&
MobilityModelSimulatorConfig::_Internal::coverage_map_cfg(const MobilityModelSimulatorConfig* msg) {
  return *msg->coverage_map_cfg_;
}
const ::pb::UAVConfig&
MobilityModelSimulatorConfig::_Internal::uav_cfg(const MobilityModelSimulatorConfig* msg) {
  return *msg->uav_cfg_;
}
MobilityModelSimulatorConfig::MobilityModelSimulatorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.MobilityModelSimulatorConfig)
}
MobilityModelSimulatorConfig::MobilityModelSimulatorConfig(const MobilityModelSimulatorConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_coverage_map_cfg()) {
    coverage_map_cfg_ = new ::pb::CoverageMapConfig(*from.coverage_map_cfg_);
  } else {
    coverage_map_cfg_ = nullptr;
  }
  if (from._internal_has_uav_cfg()) {
    uav_cfg_ = new ::pb::UAVConfig(*from.uav_cfg_);
  } else {
    uav_cfg_ = nullptr;
  }
  ::memcpy(&mobmodel_, &from.mobmodel_,
    static_cast<size_t>(reinterpret_cast<char*>(&n_uavs_) -
    reinterpret_cast<char*>(&mobmodel_)) + sizeof(n_uavs_));
  // @@protoc_insertion_point(copy_constructor:pb.MobilityModelSimulatorConfig)
}

inline void MobilityModelSimulatorConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&coverage_map_cfg_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&n_uavs_) -
    reinterpret_cast<char*>(&coverage_map_cfg_)) + sizeof(n_uavs_));
}

MobilityModelSimulatorConfig::~MobilityModelSimulatorConfig() {
  // @@protoc_insertion_point(destructor:pb.MobilityModelSimulatorConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MobilityModelSimulatorConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete coverage_map_cfg_;
  if (this != internal_default_instance()) delete uav_cfg_;
}

void MobilityModelSimulatorConfig::ArenaDtor(void* object) {
  MobilityModelSimulatorConfig* _this = reinterpret_cast< MobilityModelSimulatorConfig* >(object);
  (void)_this;
}
void MobilityModelSimulatorConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MobilityModelSimulatorConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MobilityModelSimulatorConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.MobilityModelSimulatorConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && coverage_map_cfg_ != nullptr) {
    delete coverage_map_cfg_;
  }
  coverage_map_cfg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && uav_cfg_ != nullptr) {
    delete uav_cfg_;
  }
  uav_cfg_ = nullptr;
  ::memset(&mobmodel_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&n_uavs_) -
      reinterpret_cast<char*>(&mobmodel_)) + sizeof(n_uavs_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MobilityModelSimulatorConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .pb.MobilityModel mobmodel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mobmodel(static_cast<::pb::MobilityModel>(val));
        } else
          goto handle_unusual;
        continue;
      // .pb.CoverageMapConfig coverage_map_cfg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_coverage_map_cfg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .pb.UAVConfig uav_cfg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_uav_cfg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 n_uavs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          n_uavs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MobilityModelSimulatorConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.MobilityModelSimulatorConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .pb.MobilityModel mobmodel = 1;
  if (this->_internal_mobmodel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mobmodel(), target);
  }

  // .pb.CoverageMapConfig coverage_map_cfg = 2;
  if (this->_internal_has_coverage_map_cfg()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::coverage_map_cfg(this), target, stream);
  }

  // .pb.UAVConfig uav_cfg = 3;
  if (this->_internal_has_uav_cfg()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::uav_cfg(this), target, stream);
  }

  // uint32 n_uavs = 4;
  if (this->_internal_n_uavs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_n_uavs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.MobilityModelSimulatorConfig)
  return target;
}

size_t MobilityModelSimulatorConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.MobilityModelSimulatorConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pb.CoverageMapConfig coverage_map_cfg = 2;
  if (this->_internal_has_coverage_map_cfg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *coverage_map_cfg_);
  }

  // .pb.UAVConfig uav_cfg = 3;
  if (this->_internal_has_uav_cfg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *uav_cfg_);
  }

  // .pb.MobilityModel mobmodel = 1;
  if (this->_internal_mobmodel() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mobmodel());
  }

  // uint32 n_uavs = 4;
  if (this->_internal_n_uavs() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_n_uavs());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MobilityModelSimulatorConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MobilityModelSimulatorConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MobilityModelSimulatorConfig::GetClassData() const { return &_class_data_; }

void MobilityModelSimulatorConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MobilityModelSimulatorConfig *>(to)->MergeFrom(
      static_cast<const MobilityModelSimulatorConfig &>(from));
}


void MobilityModelSimulatorConfig::MergeFrom(const MobilityModelSimulatorConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.MobilityModelSimulatorConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_coverage_map_cfg()) {
    _internal_mutable_coverage_map_cfg()->::pb::CoverageMapConfig::MergeFrom(from._internal_coverage_map_cfg());
  }
  if (from._internal_has_uav_cfg()) {
    _internal_mutable_uav_cfg()->::pb::UAVConfig::MergeFrom(from._internal_uav_cfg());
  }
  if (from._internal_mobmodel() != 0) {
    _internal_set_mobmodel(from._internal_mobmodel());
  }
  if (from._internal_n_uavs() != 0) {
    _internal_set_n_uavs(from._internal_n_uavs());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MobilityModelSimulatorConfig::CopyFrom(const MobilityModelSimulatorConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.MobilityModelSimulatorConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MobilityModelSimulatorConfig::IsInitialized() const {
  return true;
}

void MobilityModelSimulatorConfig::InternalSwap(MobilityModelSimulatorConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MobilityModelSimulatorConfig, n_uavs_)
      + sizeof(MobilityModelSimulatorConfig::n_uavs_)
      - PROTOBUF_FIELD_OFFSET(MobilityModelSimulatorConfig, coverage_map_cfg_)>(
          reinterpret_cast<char*>(&coverage_map_cfg_),
          reinterpret_cast<char*>(&other->coverage_map_cfg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MobilityModelSimulatorConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[6]);
}

// ===================================================================

class MobilityModelSimulatorFrameInfo::_Internal {
 public:
};

MobilityModelSimulatorFrameInfo::MobilityModelSimulatorFrameInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  uavs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.MobilityModelSimulatorFrameInfo)
}
MobilityModelSimulatorFrameInfo::MobilityModelSimulatorFrameInfo(const MobilityModelSimulatorFrameInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      uavs_(from.uavs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&state_, &from.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&coverage_ratio_) -
    reinterpret_cast<char*>(&state_)) + sizeof(coverage_ratio_));
  // @@protoc_insertion_point(copy_constructor:pb.MobilityModelSimulatorFrameInfo)
}

inline void MobilityModelSimulatorFrameInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&state_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&coverage_ratio_) -
    reinterpret_cast<char*>(&state_)) + sizeof(coverage_ratio_));
}

MobilityModelSimulatorFrameInfo::~MobilityModelSimulatorFrameInfo() {
  // @@protoc_insertion_point(destructor:pb.MobilityModelSimulatorFrameInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MobilityModelSimulatorFrameInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MobilityModelSimulatorFrameInfo::ArenaDtor(void* object) {
  MobilityModelSimulatorFrameInfo* _this = reinterpret_cast< MobilityModelSimulatorFrameInfo* >(object);
  (void)_this;
}
void MobilityModelSimulatorFrameInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MobilityModelSimulatorFrameInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MobilityModelSimulatorFrameInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.MobilityModelSimulatorFrameInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uavs_.Clear();
  ::memset(&state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&coverage_ratio_) -
      reinterpret_cast<char*>(&state_)) + sizeof(coverage_ratio_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MobilityModelSimulatorFrameInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .pb.MobilityModelSimulatorState state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_state(static_cast<::pb::MobilityModelSimulatorState>(val));
        } else
          goto handle_unusual;
        continue;
      // float simulation_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          simulation_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float coverage_ratio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          coverage_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .pb.UAV uavs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uavs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MobilityModelSimulatorFrameInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.MobilityModelSimulatorFrameInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .pb.MobilityModelSimulatorState state = 1;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // float simulation_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_simulation_time = this->_internal_simulation_time();
  uint32_t raw_simulation_time;
  memcpy(&raw_simulation_time, &tmp_simulation_time, sizeof(tmp_simulation_time));
  if (raw_simulation_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_simulation_time(), target);
  }

  // float coverage_ratio = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_coverage_ratio = this->_internal_coverage_ratio();
  uint32_t raw_coverage_ratio;
  memcpy(&raw_coverage_ratio, &tmp_coverage_ratio, sizeof(tmp_coverage_ratio));
  if (raw_coverage_ratio != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_coverage_ratio(), target);
  }

  // repeated .pb.UAV uavs = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_uavs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_uavs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.MobilityModelSimulatorFrameInfo)
  return target;
}

size_t MobilityModelSimulatorFrameInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.MobilityModelSimulatorFrameInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.UAV uavs = 4;
  total_size += 1UL * this->_internal_uavs_size();
  for (const auto& msg : this->uavs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .pb.MobilityModelSimulatorState state = 1;
  if (this->_internal_state() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }

  // float simulation_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_simulation_time = this->_internal_simulation_time();
  uint32_t raw_simulation_time;
  memcpy(&raw_simulation_time, &tmp_simulation_time, sizeof(tmp_simulation_time));
  if (raw_simulation_time != 0) {
    total_size += 1 + 4;
  }

  // float coverage_ratio = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_coverage_ratio = this->_internal_coverage_ratio();
  uint32_t raw_coverage_ratio;
  memcpy(&raw_coverage_ratio, &tmp_coverage_ratio, sizeof(tmp_coverage_ratio));
  if (raw_coverage_ratio != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MobilityModelSimulatorFrameInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MobilityModelSimulatorFrameInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MobilityModelSimulatorFrameInfo::GetClassData() const { return &_class_data_; }

void MobilityModelSimulatorFrameInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MobilityModelSimulatorFrameInfo *>(to)->MergeFrom(
      static_cast<const MobilityModelSimulatorFrameInfo &>(from));
}


void MobilityModelSimulatorFrameInfo::MergeFrom(const MobilityModelSimulatorFrameInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.MobilityModelSimulatorFrameInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  uavs_.MergeFrom(from.uavs_);
  if (from._internal_state() != 0) {
    _internal_set_state(from._internal_state());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_simulation_time = from._internal_simulation_time();
  uint32_t raw_simulation_time;
  memcpy(&raw_simulation_time, &tmp_simulation_time, sizeof(tmp_simulation_time));
  if (raw_simulation_time != 0) {
    _internal_set_simulation_time(from._internal_simulation_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_coverage_ratio = from._internal_coverage_ratio();
  uint32_t raw_coverage_ratio;
  memcpy(&raw_coverage_ratio, &tmp_coverage_ratio, sizeof(tmp_coverage_ratio));
  if (raw_coverage_ratio != 0) {
    _internal_set_coverage_ratio(from._internal_coverage_ratio());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MobilityModelSimulatorFrameInfo::CopyFrom(const MobilityModelSimulatorFrameInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.MobilityModelSimulatorFrameInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MobilityModelSimulatorFrameInfo::IsInitialized() const {
  return true;
}

void MobilityModelSimulatorFrameInfo::InternalSwap(MobilityModelSimulatorFrameInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  uavs_.InternalSwap(&other->uavs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MobilityModelSimulatorFrameInfo, coverage_ratio_)
      + sizeof(MobilityModelSimulatorFrameInfo::coverage_ratio_)
      - PROTOBUF_FIELD_OFFSET(MobilityModelSimulatorFrameInfo, state_)>(
          reinterpret_cast<char*>(&state_),
          reinterpret_cast<char*>(&other->state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MobilityModelSimulatorFrameInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[7]);
}

// ===================================================================

class MobilityModelSimulatorApproxMap::_Internal {
 public:
};

MobilityModelSimulatorApproxMap::MobilityModelSimulatorApproxMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  zones_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:pb.MobilityModelSimulatorApproxMap)
}
MobilityModelSimulatorApproxMap::MobilityModelSimulatorApproxMap(const MobilityModelSimulatorApproxMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      zones_(from.zones_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&rows_, &from.rows_,
    static_cast<size_t>(reinterpret_cast<char*>(&cols_) -
    reinterpret_cast<char*>(&rows_)) + sizeof(cols_));
  // @@protoc_insertion_point(copy_constructor:pb.MobilityModelSimulatorApproxMap)
}

inline void MobilityModelSimulatorApproxMap::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rows_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cols_) -
    reinterpret_cast<char*>(&rows_)) + sizeof(cols_));
}

MobilityModelSimulatorApproxMap::~MobilityModelSimulatorApproxMap() {
  // @@protoc_insertion_point(destructor:pb.MobilityModelSimulatorApproxMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MobilityModelSimulatorApproxMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MobilityModelSimulatorApproxMap::ArenaDtor(void* object) {
  MobilityModelSimulatorApproxMap* _this = reinterpret_cast< MobilityModelSimulatorApproxMap* >(object);
  (void)_this;
}
void MobilityModelSimulatorApproxMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MobilityModelSimulatorApproxMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MobilityModelSimulatorApproxMap::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.MobilityModelSimulatorApproxMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  zones_.Clear();
  ::memset(&rows_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cols_) -
      reinterpret_cast<char*>(&rows_)) + sizeof(cols_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MobilityModelSimulatorApproxMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 rows = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 cols = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          cols_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 zones = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_zones(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_zones(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MobilityModelSimulatorApproxMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.MobilityModelSimulatorApproxMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 rows = 1;
  if (this->_internal_rows() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rows(), target);
  }

  // uint32 cols = 2;
  if (this->_internal_cols() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cols(), target);
  }

  // repeated uint32 zones = 3;
  {
    int byte_size = _zones_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_zones(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.MobilityModelSimulatorApproxMap)
  return target;
}

size_t MobilityModelSimulatorApproxMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.MobilityModelSimulatorApproxMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 zones = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->zones_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _zones_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // uint32 rows = 1;
  if (this->_internal_rows() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_rows());
  }

  // uint32 cols = 2;
  if (this->_internal_cols() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_cols());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MobilityModelSimulatorApproxMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MobilityModelSimulatorApproxMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MobilityModelSimulatorApproxMap::GetClassData() const { return &_class_data_; }

void MobilityModelSimulatorApproxMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MobilityModelSimulatorApproxMap *>(to)->MergeFrom(
      static_cast<const MobilityModelSimulatorApproxMap &>(from));
}


void MobilityModelSimulatorApproxMap::MergeFrom(const MobilityModelSimulatorApproxMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pb.MobilityModelSimulatorApproxMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  zones_.MergeFrom(from.zones_);
  if (from._internal_rows() != 0) {
    _internal_set_rows(from._internal_rows());
  }
  if (from._internal_cols() != 0) {
    _internal_set_cols(from._internal_cols());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MobilityModelSimulatorApproxMap::CopyFrom(const MobilityModelSimulatorApproxMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.MobilityModelSimulatorApproxMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MobilityModelSimulatorApproxMap::IsInitialized() const {
  return true;
}

void MobilityModelSimulatorApproxMap::InternalSwap(MobilityModelSimulatorApproxMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  zones_.InternalSwap(&other->zones_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MobilityModelSimulatorApproxMap, cols_)
      + sizeof(MobilityModelSimulatorApproxMap::cols_)
      - PROTOBUF_FIELD_OFFSET(MobilityModelSimulatorApproxMap, rows_)>(
          reinterpret_cast<char*>(&rows_),
          reinterpret_cast<char*>(&other->rows_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MobilityModelSimulatorApproxMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_getter, &descriptor_table_protos_2fmobmodel_2dsimulator_2eproto_once,
      file_level_metadata_protos_2fmobmodel_2dsimulator_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pb::Vec2f* Arena::CreateMaybeMessage< ::pb::Vec2f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::Vec2f >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::Vec3f* Arena::CreateMaybeMessage< ::pb::Vec3f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::Vec3f >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::UAV* Arena::CreateMaybeMessage< ::pb::UAV >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::UAV >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::CoverageMapConfig* Arena::CreateMaybeMessage< ::pb::CoverageMapConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::CoverageMapConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::CameraConfig* Arena::CreateMaybeMessage< ::pb::CameraConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::CameraConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::UAVConfig* Arena::CreateMaybeMessage< ::pb::UAVConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::UAVConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::MobilityModelSimulatorConfig* Arena::CreateMaybeMessage< ::pb::MobilityModelSimulatorConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::MobilityModelSimulatorConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::MobilityModelSimulatorFrameInfo* Arena::CreateMaybeMessage< ::pb::MobilityModelSimulatorFrameInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::MobilityModelSimulatorFrameInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::MobilityModelSimulatorApproxMap* Arena::CreateMaybeMessage< ::pb::MobilityModelSimulatorApproxMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::MobilityModelSimulatorApproxMap >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
